From acc46d4e41d709d8f44cd5cdbcdec0d0f553eb3d Mon Sep 17 00:00:00 2001
From: Roger Luethi <roger.luethi@bisdn.de>
Date: Thu, 10 Mar 2022 11:44:58 +0100
Subject: [PATCH] Add ofdpa_vpws.py: sample code for MPLS pseudowires

This commit adds a ryu app that can be used to configure MPLS
pseudowires. It depends on a version of ryu with support for ofdpa
extensions that are not present in upstream ryu.

To start the application:

/usr/bin/ryu-manager ryu.app.bisdn.ofdpa_vpws \
    --config-file /etc/ryu/vpws.conf

The configuration file should look something like this:
---------------------------------------------------------------------
[DEFAULT]
first_port = 1
last_port = 2

first_vlan = 1
last_vlan = 5

mpls_port = 54

mac_self = "00:00:00:00:00:01"
mac_peer = "00:11:11:11:11:01"

outer_label_ingress = 65536

outer_label_egress = 131072

pcap_file = "/var/log/ryu.pcap"
---------------------------------------------------------------------

This sample configuration would build one bidirectional pseudowire
for VLAN ids 1 through 5 on ports 1 and 2 of the switch, with each
pseudowire getting a unique inner MPLS label.

MPLS traffic would all be sent to port 54 (and received from there) to
a L2 peer with the MAC address 00:11:11:11:11:01. The outer MPLS label
for outgoing traffic would be set to 0x20000 and would be expected to
be 0x10000 for incoming MPLS traffic which would then be distributed
to VLAN ids 1 through 5 on ports 1 and 2 according to the inner MPLS
label of incoming packets.

If you wanted to configure two switches back-to-back (for testing
purposes) and have them communicate via pseudowires, the configuration
file on the second switch would have to swap the MAC addresses (mac_self,
mac_peer) and the outer labels.

This ryu application writes incoming ARP and IP packets to a pcap
file. Note that outgoing packets are invisible to the controller.

Signed-off-by: Roger Luethi <roger.luethi@bisdn.de>
---
 ryu/app/bisdn/ofdpa_vpws.py | 1297 +++++++++++++++++++++++++++++++++++
 1 file changed, 1297 insertions(+)
 create mode 100644 ryu/app/bisdn/ofdpa_vpws.py

diff --git a/ryu/app/bisdn/ofdpa_vpws.py b/ryu/app/bisdn/ofdpa_vpws.py
new file mode 100644
index 00000000..e2704f84
--- /dev/null
+++ b/ryu/app/bisdn/ofdpa_vpws.py
@@ -0,0 +1,1297 @@
+# Copyright (C) 2011 Nippon Telegraph and Telephone Corporation.
+# (C) Copyright Broadcom Corporation 2013-2014
+# Copyright 2021 BISDN GmbH
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Code based on:
+# - OpenFlow Data Plane Abstraction (OF-DPA): Abstract Switch Specification
+#       Version 2.0 (October 6, 2014)
+#     Retrieved from https://docs.broadcom.com/doc/12378911
+#     Page numbers in the code refer to this PDF document, ofdpa_spec_2.pdf
+# - OpenFlow v1.3 Messages and Structures
+#     Retrieved from https://ryu.readthedocs.io/en/latest/ofproto_v1_3_ref.html
+# - OpenFlow - Data Plane Abstraction
+#     Retrieved from https://github.com/Broadcom-Switch/of-dpa.git
+# - ryu
+#     Retrieved from https://github.com/faucetsdn/ryu.git
+# - OpenFlow Switch Specification Version 1.3.1 (Wire Protocol 0x04)
+#     September 6, 2012
+#     Retrieved from https://www.opennetworking.org/wp-content/uploads/2013/04/
+#       openflow-spec-v1.3.1.pdf
+
+###############################################################################
+# PyLint Messages http://pylint-messages.wikidot.com/all-messages
+#
+# pylint config (taken from ryu's .pylintrc)
+# C0111: Don't require docstrings on every method
+# W0511: TODOs in code comments are fine.
+# E0602: Undefined variable %r
+# C0103: Invalid name "%s" (should match %s)
+# E1101: %s %r has no %r member
+# R0903: Too few public methods (%s/%s)
+# W0614: Unused import %s from wildcard import
+# R0801: Similar lines in %s files
+# pylint: disable=C0111,W0511,E0602,C0103,E1101,R0903,W0614,R0801
+#
+# Added for ofdpa_vpws:
+# C0302: Too many lines in module
+# pylint: disable=C0302
+
+"""
+This ryu controller is intended for demonstrating the configuration of MPLS
+pseudowires with ryu on OF-DPA platforms.
+
+Copy this file to a place where it can be found (e.g., your current working
+directory or /usr/lib/python*/site-packages/ryu/app/bisdn/ofdpa_vpws.py) and
+start the application:
+
+/usr/bin/ryu-manager ryu.app.bisdn.ofdpa_vpws --config-file /etc/ryu/vpws.conf
+
+The configuration file should look something like this:
+-------------------------------------------------------------------------------
+[DEFAULT]
+first_port = 1
+last_port = 2
+
+first_vlan = 1
+last_vlan = 5
+
+mpls_port = 54
+
+mac_self = "00:00:00:00:00:01"
+mac_peer = "00:11:11:11:11:01"
+
+# 65536 is 0x10000
+outer_label_ingress = 65536
+
+# 131072 is 0x20000
+outer_label_egress = 131072
+
+# (optional) packet log for incoming traffic
+pcap_file = "/var/log/ryu.pcap"
+-------------------------------------------------------------------------------
+
+This sample configuration would build one bidirectional pseudowire for VLAN ids
+1 through 5 on ports 1 and 2 of the switch, with each pseudowire getting a
+unique inner MPLS label.
+
+MPLS traffic would all be sent to port 54 (and received from there) to a L2
+peer with the MAC address 00:11:11:11:11:01. The outer MPLS label for outgoing
+traffic would be set to 0x20000 and would be expected to be 0x10000 for
+incoming MPLS traffic which would then be distributed to VLAN ids 1 through 5
+on ports 1 and 2 according to the inner MPLS label of incoming packets.
+
+If you wanted to configure two switches back-to-back (for testing purposes) and
+have them communicate via pseudowires, the configuration file on the second
+switch would have to swap the MAC addresses (mac_self, mac_peer) and the outer
+labels.
+
+This ryu application writes incoming ARP and IP packets to a pcap file. Note
+that outgoing packets are invisible to the controller.
+"""
+
+import logging
+
+from ryu.base import app_manager
+from ryu.controller import ofp_event
+from ryu.controller.dpset import EventDP
+from ryu.controller.handler import MAIN_DISPATCHER
+from ryu.controller.handler import set_ev_cls
+from ryu.ofproto import ofproto_v1_3 as ofproto
+from ryu.lib import pcaplib
+from ryu.lib.packet import ether_types
+from ryu import cfg
+
+###############################################################################
+LOG = logging.getLogger(__name__)
+
+###############################################################################
+# Python 3.4 contains an enum implementation. We follow the style used by ryu
+# (as of ryu 4.34) instead.
+
+# Constants from https://github.com/Broadcom-Switch/of-dpa.git
+# src/include/ofdpa_datatypes.h
+
+# VLAN Id Exact Mask
+OFDPA_VID_EXACT_MASK = 0x0FFF
+
+# OFDPA_FLOW_TABLE_ID_t
+OFDPA_FLOW_TABLE_ID_VLAN = 10
+OFDPA_FLOW_TABLE_ID_MPLS_L2_PORT = 13
+OFDPA_FLOW_TABLE_ID_TERMINATION_MAC = 20
+OFDPA_FLOW_TABLE_ID_MPLS_1 = 24
+OFDPA_FLOW_TABLE_ID_MPLS_2 = 25
+OFDPA_FLOW_TABLE_ID_MPLS_TYPE = 29
+OFDPA_FLOW_TABLE_ID_ACL_POLICY = 60
+
+# OFDPA_GROUP_ENTRY_TYPE_t
+OFDPA_GROUP_ENTRY_TYPE_L2_INTERFACE = 0x0
+OFDPA_GROUP_ENTRY_TYPE_MPLS_LABEL = 0x9
+OFDPA_GROUP_ENTRY_TYPE_L2_UNFILTERED_INTERFACE = 0xB
+
+# OFDPA_MPLS_LABEL_SUBTYPE_t
+OFDPA_MPLS_INTERFACE = 0
+OFDPA_MPLS_L2_VPN_LABEL = 1
+OFDPA_MPLS_TUNNEL_LABEL1 = 3
+
+# OFDPA_TUNNELID_TYPE_t
+OFDPA_TUNNELID_TYPE_MPLS_TP = 0x0001
+
+# OFDPA_MPLS_TYPE_t
+OFDPA_MPLS_TYPE_VPWS = 1
+
+# OFDPA_MPLS_L2_PORT_TYPE_t
+OFDPA_MPLS_L2_PORT_TYPE_VPWS_LOCAL = 0x0
+OFDPA_MPLS_L2_PORT_TYPE_VPWS_NW = 0x2
+
+###############################################################################
+# With OF-DPA, packets must have an associated VLAN id in order to be processed
+# by tables following the VLAN Flow Table. For untagged packets, we add an
+# (arbitrarily chosen) OFDPA_VLAN.
+OFDPA_VLAN = 4095
+
+###############################################################################
+# Convenient reminder of values imported from ryu:
+# OFPVID_NONE    = 0x0000
+# OFPVID_PRESENT = 0x1000
+
+# ETH_TYPE_ARP   = 0x0806
+# ETH_TYPE_IP    = 0x0800
+# ETH_TYPE_IPV6  = 0x86DD
+# ETH_TYPE_LLDP  = 0x88CC
+
+
+###############################################################################
+def create_tunnel_id_closure():
+    """
+    We need unique ids for any combination of port (8 bits), vlan (12 bits),
+    and mpls_l2_port, but tunnel_id provides only 16 bits to store the id.
+    """
+    entries = {}
+
+    def _create_tunnel_id(port, vlan, mpls_l2_port_id):
+        if (port, vlan, mpls_l2_port_id) not in entries:
+            tunnel_id = OFDPA_TUNNELID_TYPE_MPLS_TP << 16 | len(entries)
+            entries[port, vlan, mpls_l2_port_id] = tunnel_id
+        return entries[port, vlan, mpls_l2_port_id]
+
+    return _create_tunnel_id
+
+
+create_tunnel_id = create_tunnel_id_closure()
+
+
+###############################################################################
+def create_mpls_l2_port_id(_port, _vlan):
+    """
+    Some day we may find out that that we cannot always use the same
+    mpls_l2_port_id. So far, any 16 bit number seems to work.
+    """
+    return 0xBEEF
+
+
+###############################################################################
+def create_flow_id_closure():
+    """
+    We need unique flow ids, which are used as entry_id and OpenFlow cookies.
+    OpenFlow cookies are 64 bit values which should be large enough to never
+    roll over.
+    """
+    last_flow_id = 0
+
+    def _create_flow_id(new_counter_value=None):
+        nonlocal last_flow_id
+
+        # Resetting the flow id counter makes it possible to have identical
+        # flow ids when repeating tests.
+        if new_counter_value is not None:
+            last_flow_id = new_counter_value
+            return last_flow_id
+
+        last_flow_id += 1
+        return last_flow_id
+
+    return _create_flow_id
+
+
+create_flow_id = create_flow_id_closure()
+
+
+###############################################################################
+def send_flow_mod(
+    datapath,
+    buffer_id=ofproto.OFP_NO_BUFFER,
+    command=ofproto.OFPFC_ADD,
+    cookie=0,
+    cookie_mask=0,
+    flags=0,
+    hard_timeout=0,
+    idle_timeout=0,
+    instructions=None,
+    match=None,
+    out_group=0,
+    out_port=0,
+    priority=0,
+    table_id=0,
+):
+    # pylint: disable=too-many-arguments,too-many-locals
+    """
+    This function overrides one default value of OFPFlowMod:
+    priority  (ryu default: ofproto.OFP_DEFAULT_PRIORITY [32768, 0x8000])
+
+    See ryu.ofproto.ofproto_v1_3_parser.OFPFlowMod
+    https://ryu.readthedocs.io/en/latest/ofproto_v1_3_ref.html
+    """
+    parser = datapath.ofproto_parser
+
+    flow_mod = parser.OFPFlowMod(
+        datapath,
+        cookie=cookie,
+        cookie_mask=cookie_mask,
+        table_id=table_id,
+        command=command,
+        idle_timeout=idle_timeout,
+        hard_timeout=hard_timeout,
+        priority=priority,
+        buffer_id=buffer_id,
+        out_port=out_port,
+        out_group=out_group,
+        flags=flags,
+        match=match,
+        instructions=instructions,
+    )
+
+    datapath.send_msg(flow_mod)
+
+
+###############################################################################
+class OfdpaTable:
+    """
+    Parent class for all flow table and group table classes.
+    """
+
+    datapath = None
+
+    def __init__(self):
+        # Keep track of existing entries to avoid adding them multiple times.
+        self.entries = []
+
+
+###############################################################################
+class GroupTable_L2_Interface(OfdpaTable):
+    def add_entry(self, datapath, port, vlan):
+        """
+        Create OF-DPA L2 Interface Group entry. Store port to interface group
+        association in instance dict.
+
+        port: physical switch port number
+        vlan: vlan id (defaults to not OFDPA_VLAN)
+        """
+        group_type = OFDPA_GROUP_ENTRY_TYPE_L2_INTERFACE
+
+        if vlan == 0:
+            # OFDPA_VLAN is the vlan we add to untagged packets.
+            vlan = OFDPA_VLAN
+
+        # Note: The information encoded in this group_id is interpreted
+        #       by ofdpa!
+        group_id = group_type << 28 | vlan << 16 | port
+
+        if group_id in self.entries:
+            return group_id
+
+        parser = datapath.ofproto_parser
+
+        actions = []
+        actions.append(parser.OFPActionOutput(port))
+
+        if vlan == OFDPA_VLAN:
+            # Have the group entry remove the tag marking untagged packets
+            # before sending them out.
+            actions.append(parser.OFPActionPopVlan())
+
+        buckets = [parser.OFPBucket(actions=actions)]
+
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPFC_ADD,
+            type_=ofproto.OFPGT_INDIRECT,
+            group_id=group_id,
+            buckets=buckets,
+        )
+        datapath.send_msg(group_mod)
+
+        self.entries.append(group_id)
+
+        return group_id
+
+    # -------------------------------------------------------------------------
+    def add_unfiltered_entry(self, datapath, port):
+        """
+        Create OF-DPA Unfiltered L2 Interface Group entry (does neither
+        egress VLAN filtering nor tagging).
+
+        port: physical switch port number
+        """
+        group_type = OFDPA_GROUP_ENTRY_TYPE_L2_UNFILTERED_INTERFACE
+
+        group_id = group_type << 28 | port
+
+        if group_id in self.entries:
+            return group_id
+
+        parser = datapath.ofproto_parser
+
+        actions = []
+        actions.append(parser.OFPActionOutput(port))
+
+        actions.append(parser.OFPActionSetField(ofdpa_allow_vlan_translation=1))
+
+        buckets = [parser.OFPBucket(actions=actions)]
+
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPFC_ADD,
+            type_=ofproto.OFPGT_INDIRECT,
+            group_id=group_id,
+            buckets=buckets,
+        )
+        datapath.send_msg(group_mod)
+
+        self.entries.append(group_id)
+
+        return group_id
+
+
+gt_l2_interface = GroupTable_L2_Interface()
+
+
+###############################################################################
+class GroupTable_MPLS_Interface(OfdpaTable):
+    def __init__(self):
+        super().__init__()
+        self.entries = {}
+        self._index = 0
+
+    def add_entry(self, datapath, l2_if_gid, vlan_id, eth_src, eth_dst):
+        # pylint: disable=too-many-arguments
+        """
+        Create group for editing Ethernet header of MPLS pseudowire packets.
+
+        l2_if_gid: group_id of L2 Interface
+        vlan_id: vlan id for packets passed to l2_if_gid
+        eth_src: source mac address for new ethernet header
+        eth_dst: destination mac address for new ethernet header
+        """
+        group_id = self.entries.get((l2_if_gid, vlan_id, eth_src, eth_dst))
+        if group_id is not None:
+            return group_id
+
+        group_type = OFDPA_GROUP_ENTRY_TYPE_MPLS_LABEL
+        group_subtype = OFDPA_MPLS_INTERFACE
+        group_id = group_type << 28 | group_subtype << 24 | self._index
+
+        self._index += 1
+
+        parser = datapath.ofproto_parser
+
+        actions = []
+        buckets = []
+
+        if vlan_id == 0:
+            # Untagged packets have been tagged with OFDPA_VLAN.
+            vlan_id = OFDPA_VLAN
+
+        action = parser.OFPActionSetField(vlan_vid=ofproto.OFPVID_PRESENT | vlan_id)
+        actions.append(action)
+
+        action = parser.OFPActionSetField(eth_src=eth_src)
+        actions.append(action)
+
+        action = parser.OFPActionSetField(eth_dst=eth_dst)
+        actions.append(action)
+
+        action = parser.OFPActionGroup(l2_if_gid)
+        actions.append(action)
+
+        bucket = parser.OFPBucket(
+            weight=0,
+            watch_port=ofproto.OFPP_ANY,
+            watch_group=ofproto.OFPG_ANY,
+            actions=actions,
+        )
+        buckets.append(bucket)
+
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPFC_ADD,
+            type_=ofproto.OFPGT_INDIRECT,
+            group_id=group_id,
+            buckets=buckets,
+        )
+        datapath.send_msg(group_mod)
+
+        self.entries[l2_if_gid, vlan_id, eth_src, eth_dst] = group_id
+
+        return group_id
+
+
+gt_mpls_interface = GroupTable_MPLS_Interface()
+
+
+###############################################################################
+class GroupTable_MPLS_L2_VPN_Label(OfdpaTable):
+    def __init__(self):
+        super().__init__()
+        self.entries = {}
+        self._index = 0
+
+    def add_entry(self, datapath, mpls_label, mpls_group_id):
+        """
+        Create group that adds a new L2 header, inserts an MPLS label
+        and pushes packet either to an MPLS Interface Group or (if an
+        outer MPLS label is needed) to an MPLS Tunnel Label Group.
+
+        mpls_label: inner MPLS label for outgoing packet
+        mpls_group_id: pass packets on to this group (either an MPLS
+                       Interface group or an MPLS L2 Tunnel Label group)
+        """
+        group_id = self.entries.get((mpls_label, mpls_group_id))
+        if group_id is not None:
+            return group_id
+
+        group_type = OFDPA_GROUP_ENTRY_TYPE_MPLS_LABEL
+        group_subtype = OFDPA_MPLS_L2_VPN_LABEL
+        group_id = group_type << 28 | group_subtype << 24 | self._index
+
+        self._index += 1
+
+        # The VPN Label is the innermost (bottom of stack) label.
+        mpls_bos = 1
+
+        parser = datapath.ofproto_parser
+
+        actions = []
+        buckets = []
+
+        action = parser.OFDPAActionPushL2Header()
+        actions.append(action)
+
+        # Set MPLS ethertype in Ethernet header (default: ETH_TYPE_MPLS 0x8847)
+        action = parser.OFPActionPushMpls()
+        actions.append(action)
+
+        # Push Control Word
+        action = parser.OFDPAActionPushCw()
+        actions.append(action)
+
+        # Set MPLS label
+        action = parser.OFPActionSetField(mpls_label=mpls_label)
+        actions.append(action)
+
+        action = parser.OFPActionSetField(mpls_bos=mpls_bos)
+        actions.append(action)
+
+        action = parser.OFPActionGroup(mpls_group_id)
+        actions.append(action)
+
+        bucket = parser.OFPBucket(
+            weight=0,
+            watch_port=ofproto.OFPP_ANY,
+            watch_group=ofproto.OFPG_ANY,
+            actions=actions,
+        )
+        buckets.append(bucket)
+
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPFC_ADD,
+            type_=ofproto.OFPGT_INDIRECT,
+            group_id=group_id,
+            buckets=buckets,
+        )
+        datapath.send_msg(group_mod)
+
+        self.entries[mpls_label, mpls_group_id] = group_id
+
+        return group_id
+
+
+gt_mpls_l2_vpn_label = GroupTable_MPLS_L2_VPN_Label()
+
+
+###############################################################################
+class GroupTable_MPLS_L2_Tunnel_Label(OfdpaTable):
+    def __init__(self):
+        super().__init__()
+        self.entries = {}
+        self._index = 0
+
+    def add_entry(self, datapath, mpls_label, mpls_interface_group_id):
+        """
+        Create group that inserts an outer MPLS label (tunnel label)
+        into an existing MPLS header and pushes the packet to an MPLS
+        Interface Group.
+
+        mpls_label: outer MPLS label for outgoing packet
+        mpls_group_id: pass packets on to this MPLS Interface group
+        """
+        group_id = self.entries.get((mpls_label, mpls_interface_group_id))
+        if group_id is not None:
+            return group_id
+
+        group_type = OFDPA_GROUP_ENTRY_TYPE_MPLS_LABEL
+        group_subtype = OFDPA_MPLS_TUNNEL_LABEL1
+        group_id = group_type << 28 | group_subtype << 24 | self._index
+
+        self._index += 1
+
+        parser = datapath.ofproto_parser
+
+        actions = []
+        buckets = []
+
+        # Set MPLS ethertype in Ethernet header (default: ETH_TYPE_MPLS 0x8847)
+        # XXX FIXME TODO OFPActionPushMpls() vs OFPActionPushMpls(0)
+        action = parser.OFPActionPushMpls()
+        actions.append(action)
+
+        # Set outer/tunnel MPLS label
+        action = parser.OFPActionSetField(mpls_label=mpls_label)
+        actions.append(action)
+
+        action = parser.OFPActionGroup(mpls_interface_group_id)
+        actions.append(action)
+
+        bucket = parser.OFPBucket(
+            weight=0,
+            watch_port=ofproto.OFPP_ANY,
+            watch_group=ofproto.OFPG_ANY,
+            actions=actions,
+        )
+        buckets.append(bucket)
+
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPFC_ADD,
+            type_=ofproto.OFPGT_INDIRECT,
+            group_id=group_id,
+            buckets=buckets,
+        )
+        datapath.send_msg(group_mod)
+
+        self.entries[mpls_label, mpls_interface_group_id] = group_id
+
+        return group_id
+
+
+gt_mpls_l2_tunnel_label = GroupTable_MPLS_L2_Tunnel_Label()
+
+
+###############################################################################
+class FlowTable_10_VLAN(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_VLAN
+    goto_table = OFDPA_FLOW_TABLE_ID_TERMINATION_MAC
+
+    def add_entry(self, datapath, port, vlan):
+        """
+        Add entries to VLAN Flow Table.
+
+        Select incoming traffic on specified port and vlan for use in
+        Flow Table 20. If vlan == 0, all traffic on the port is selected
+        and packets are tagged with OFDPA_VLAN.
+        """
+        key = vlan << 8 | port
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+        if vlan:
+            self._add_tagged_vlan(datapath, port, vlan)
+        else:
+            # Tag untagged traffic with OFDPA_VLAN tag and pretend it was
+            # tagged like that to begin with.
+            self._add_tagged_vlan(datapath, port, OFDPA_VLAN)
+            self._add_untagged_vlan(datapath, port, OFDPA_VLAN)
+
+    ###########################################################################
+    def _add_tagged_vlan(self, datapath, port, vlan):
+        """
+        Add VLAN Filtering entry to VLAN Flow Table.
+
+        Select incoming traffic from given port and vlan for use in
+        Flow Table 20.
+        """
+        parser = datapath.ofproto_parser
+
+        fields = {}
+        fields["in_port"] = port
+
+        # All tagged packets are represented by VLAN id values between 0x1001
+        # and 0x1FFE (OFPVID_PRESENT | VLAN id value).
+        fields["vlan_vid"] = (
+            vlan | ofproto.OFPVID_PRESENT,
+            ofproto.OFPVID_PRESENT | OFDPA_VID_EXACT_MASK,
+        )
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+    ###########################################################################
+    def _add_untagged_vlan(self, datapath, port, vlan=OFDPA_VLAN):
+        """
+        Add Untagged Packet Port VLAN Assignment entry to VLAN Flow Table.
+
+        vlan: internal vlan to assign to untagged packets
+        """
+        parser = datapath.ofproto_parser
+
+        # All tagged packets are represented by VLAN id values between 0x1001
+        # and 0x1FFE (OFPVID_PRESENT | VLAN id value).
+
+        fields = {}
+        fields["in_port"] = port
+
+        # Not obvious from the spec, but just plain 0 seems required here.
+        fields["vlan_vid"] = ofproto.OFPVID_NONE
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+
+        # Set vlan for untagged packets.
+        actions = []
+        actions.append(
+            parser.OFPActionSetField(vlan_vid=(vlan | ofproto.OFPVID_PRESENT))
+        )
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)
+        instructions.append(instruction)
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_10_vlan = FlowTable_10_VLAN()
+
+
+###############################################################################
+class FlowTable_10_VLAN_MPLS(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_VLAN
+    goto_table = OFDPA_FLOW_TABLE_ID_MPLS_L2_PORT
+
+    def add_mpls_entry(self, datapath, vlan, port, tunnel_id, mpls_l2_port_id):
+        # pylint: disable=too-many-arguments
+        """
+        Select incoming vlan traffic and assign tunnel_id, mpls_l2_port_id for
+        use in Flow Table 13.
+        """
+        key = (vlan, port)
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+        parser = datapath.ofproto_parser
+
+        fields = {}
+        fields["in_port"] = port
+
+        if vlan == ofproto.OFPVID_NONE:
+            # For vlan_vid = 0, set mask 0 to catch all traffic, tagged and
+            # untagged.
+            fields["vlan_vid"] = (0, 0)
+        else:
+            fields["vlan_vid"] = (
+                vlan | ofproto.OFPVID_PRESENT,
+                ofproto.OFPVID_PRESENT | OFDPA_VID_EXACT_MASK,
+            )
+
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+        actions = []
+
+        action = parser.OFPActionSetField(
+            ofdpa_mpls_l2_port=OFDPA_MPLS_L2_PORT_TYPE_VPWS_LOCAL << 16
+            | mpls_l2_port_id
+        )
+        actions.append(action)
+
+        action = parser.OFPActionSetField(tunnel_id=tunnel_id)
+        actions.append(action)
+
+        action = parser.OFPActionSetField(ofdpa_mpls_type=OFDPA_MPLS_TYPE_VPWS)
+        actions.append(action)
+
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)
+        instructions.append(instruction)
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_10_vlan_mpls = FlowTable_10_VLAN_MPLS()
+
+
+###############################################################################
+class FlowTable_13_MPLS_L2_Port(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_MPLS_L2_PORT
+    goto_table = OFDPA_FLOW_TABLE_ID_ACL_POLICY
+
+    def add_entry(self, datapath, mpls_label_l2_group_id, tunnel_id, mpls_l2_port):
+        """
+        Create a flow entry that pushes packets with given tunnel_id and
+        mpls_l2_port_id to mpls_label_l2_group_id.
+        """
+        key = (mpls_label_l2_group_id, tunnel_id, mpls_l2_port)
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+
+        parser = datapath.ofproto_parser
+
+        fields = {}
+        fields["ofdpa_mpls_l2_port"] = (
+            OFDPA_MPLS_L2_PORT_TYPE_VPWS_LOCAL << 16 | mpls_l2_port
+        )
+        fields["tunnel_id"] = tunnel_id
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+        actions = []
+
+        action = parser.OFPActionGroup(mpls_label_l2_group_id)
+        actions.append(action)
+
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_WRITE_ACTIONS, actions)
+        instructions.append(instruction)
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_13_mpls_l2_port = FlowTable_13_MPLS_L2_Port()
+
+
+###############################################################################
+class FlowTable_20_Termination(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_TERMINATION_MAC
+    goto_table = OFDPA_FLOW_TABLE_ID_MPLS_1
+
+    def add_entry(self, datapath, vlan, eth_dst):
+        """
+        Detect incoming MPLS packets and send them to the MPLS table.
+
+        vlan: VLAN id of incoming MPLS packets
+        eth_dst: destination MAC address of incoming packets
+        """
+        key = str(vlan) + eth_dst
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+
+        parser = datapath.ofproto_parser
+
+        if vlan == 0:
+            # OFDPA_VLAN is the vlan we add to untagged packets.
+            vlan = OFDPA_VLAN
+
+        fields = {}
+        fields["vlan_vid"] = vlan | ofproto.OFPVID_PRESENT
+        fields["eth_type"] = 0x8847
+        fields["eth_dst"] = eth_dst
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_20_termination = FlowTable_20_Termination()
+
+
+###############################################################################
+class Flow_24_MPLS_PW_Terminate(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_MPLS_1
+    goto_table = OFDPA_FLOW_TABLE_ID_MPLS_TYPE
+
+    def add_entry(
+        self,
+        datapath,
+        l2_unfiltered_interface_group_id,
+        mpls_label,
+        tunnel_id,
+        mpls_l2_port_id,
+    ):
+        # pylint: disable=too-many-arguments
+        """
+        Push incoming MPLS packets with given inner MPLS label to the given L2
+        port (after popping their MPLS L2 header).
+        """
+        key = (l2_unfiltered_interface_group_id, mpls_label, tunnel_id, mpls_l2_port_id)
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+
+        parser = datapath.ofproto_parser
+
+        fields = {}
+        fields["eth_type"] = 0x8847
+        fields["mpls_label"] = mpls_label
+        fields["mpls_bos"] = 1
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+        actions = []
+
+        action = parser.OFPActionPopMpls(0)
+        actions.append(action)
+
+        action = parser.OFDPAActionPopL2Header()
+        actions.append(action)
+
+        action = parser.OFPActionSetField(
+            ofdpa_mpls_l2_port=OFDPA_MPLS_L2_PORT_TYPE_VPWS_NW << 16 | mpls_l2_port_id
+        )
+        actions.append(action)
+
+        action = parser.OFPActionSetField(tunnel_id=tunnel_id)
+        actions.append(action)
+
+        action = parser.OFPActionSetField(ofdpa_mpls_type=OFDPA_MPLS_TYPE_VPWS)
+        actions.append(action)
+
+        action = parser.OFDPAActionPopCwOrAch()
+        actions.append(action)
+
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)
+        instructions.append(instruction)
+
+        actions = []
+
+        action = parser.OFPActionGroup(l2_unfiltered_interface_group_id)
+        actions.append(action)
+
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_WRITE_ACTIONS, actions)
+        instructions.append(instruction)
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_24_mpls_pw_terminate = Flow_24_MPLS_PW_Terminate()
+
+
+###############################################################################
+class FlowTable_24_MPLS_Outer_Label(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_MPLS_1
+    goto_table = OFDPA_FLOW_TABLE_ID_MPLS_2
+
+    def add_entry(self, datapath, mpls_label):
+        """
+        Drop given outer MPLS label.
+        """
+        key = mpls_label
+        if key in self.entries:
+            return
+
+        self.entries.append(key)
+
+        parser = datapath.ofproto_parser
+
+        fields = {}
+        fields["eth_type"] = 0x8847
+        fields["mpls_label"] = mpls_label
+        fields["mpls_bos"] = 0
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+        actions = []
+
+        action = parser.OFPActionPopMpls(0x8847)
+        actions.append(action)
+
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)
+        instructions.append(instruction)
+
+        actions = []
+
+        instruction = parser.OFPInstructionGotoTable(self.goto_table)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+
+ft_24_drop_outer_label = FlowTable_24_MPLS_Outer_Label()
+
+
+###############################################################################
+class FlowTable_60_ACL_Policy(OfdpaTable):
+    flow_table = OFDPA_FLOW_TABLE_ID_ACL_POLICY
+
+    def add_entry(self, datapath, fields, controller_only=False):
+        """
+        Set up an ACL Policy Table entry to send packets selected by
+        fields to the controller. Set controller_only to True in order to
+        have packets redirected (instead of copied) to the controller.
+        """
+        parser = datapath.ofproto_parser
+
+        matches = parser.OFPMatch(**fields)
+
+        instructions = []
+
+        if controller_only:
+            # Forget all other actions, effectively dropping the packet.
+            instruction = parser.OFPInstructionActions(
+                ofproto.OFPIT_CLEAR_ACTIONS, actions={}
+            )
+            instructions.append(instruction)
+
+        # Send to controller
+        actions = []
+        actions.append(parser.OFPActionOutput(ofproto.OFPP_CONTROLLER))
+        instruction = parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)
+        instructions.append(instruction)
+
+        send_flow_mod(
+            datapath,
+            instructions=instructions,
+            match=matches,
+            table_id=self.flow_table,
+        )
+
+        LOG.info("Entry added to ACL Policy Table: %s", fields)
+
+
+ft_60_send_pkt_to_controller = FlowTable_60_ACL_Policy()
+
+
+###############################################################################
+class Vpws(app_manager.RyuApp):
+    """
+    This class implements a ryu controller used for testing.
+    """
+
+    OFP_VERSIONS = [ofproto.OFP_VERSION]
+
+    # Init switch, handshake
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+        # Read configuration INI-file passed via ryu-manager --config-file
+        self.pwc = cfg.CONF
+        self.pwc.register_opts(
+            [
+                cfg.IntOpt("first_port", default=1, help=("First port in range")),
+                cfg.IntOpt("last_port", default=1, help=("Last port in range")),
+                cfg.IntOpt("first_vlan", default=1, help=("First VLAN in range")),
+                cfg.IntOpt("last_vlan", default=4, help=("Last VLAN in range")),
+                cfg.IntOpt("mpls_port", default=54, help=("Upstream MPLS port")),
+                cfg.StrOpt(
+                    "mac_self",
+                    default="00:11:11:11:11:01",
+                    help=("Source MAC address",),
+                ),
+                cfg.StrOpt(
+                    "mac_peer",
+                    default="00:00:00:00:00:01",
+                    help=("Destination MAC address"),
+                ),
+                # Outer MPLS labels
+                cfg.IntOpt(
+                    "outer_label_ingress",
+                    default=0x10000,
+                    help=("Ingress MPLS outer label"),
+                ),
+                cfg.IntOpt(
+                    "outer_label_egress",
+                    default=0x20000,
+                    help=("Egress MPLS outer label"),
+                ),
+                cfg.StrOpt(
+                    "pcap_file",
+                    default=None,
+                    help=("Write incoming packets to this pcap file"),
+                ),
+            ]
+        )
+
+        self.logger.info(
+            "config: first_port: %d, last_port: %d, "
+            "first_vlan: %d, last_vlan: %d, "
+            "mpls_port: %d, "
+            "mac_self: %s, mac_peer: %s, "
+            "outer_label_ingress: 0x%x, outer_label_egress: 0x%x, "
+            "pcap_file: %s",
+            self.pwc.first_port,
+            self.pwc.last_port,
+            self.pwc.first_vlan,
+            self.pwc.last_vlan,
+            self.pwc.mpls_port,
+            self.pwc.mac_self,
+            self.pwc.mac_peer,
+            self.pwc.outer_label_ingress,
+            self.pwc.outer_label_egress,
+            self.pwc.pcap_file,
+        )
+
+        if self.pwc.pcap_file:
+            # Create pcap writer object for logging incoming packets.
+            # pylint: disable=consider-using-with
+            self.pcap_writer = pcaplib.Writer(open(self.pwc.pcap_file, "wb"))
+
+    @set_ev_cls(EventDP, MAIN_DISPATCHER)
+    def switch_connect_event(self, ev):
+        """
+        Configure pseudowires on switch when it connects.
+        """
+
+        #######################################################################
+        # Set variables
+        #######################################################################
+        if not ev.enter:
+            # Switch disconnected.
+            return
+
+        datapath = ev.dp
+
+        self.logger.info("###################################################")
+        self.logger.info("SWITCH CONNECTED")
+
+        #######################################################################
+        # Purge flow and group tables
+        #######################################################################
+
+        # Delete the flows first because dependencies keep us from deleting the
+        # groups otherwise.
+        self.delete_all_flows(datapath)
+
+        # Make sure no flows are left when we delete groups (typically relevant
+        # when large numbers of entries have to be deleted).
+        datapath.send_barrier()
+
+        self.delete_all_groups(datapath)
+
+        for plain_port in range(self.pwc.first_port, self.pwc.last_port + 1):
+            for vlan_id in range(self.pwc.first_vlan, self.pwc.last_vlan + 1):
+                self.logger.info(
+                    "Configuring pseudowire port %s vlan %s", plain_port, vlan_id
+                )
+                self.create_vpws(
+                    datapath,
+                    plain_port=plain_port,
+                    vlan=vlan_id,
+                    vpws_port=self.pwc.mpls_port,
+                )
+
+        # Send copies of ARP and IP packets to the controller to have them
+        # written to the pcap file. Note that matching is done on the inner
+        # L2 header (we cannot match ETH_TYPE_MPLS), but packets are written
+        # to the pcap file _with_ the MPLS L2 header (if any).
+        self.copy_packets_to_controller(datapath, ether_type=ether_types.ETH_TYPE_ARP)
+        self.copy_packets_to_controller(datapath, ether_type=ether_types.ETH_TYPE_IP)
+
+        self.logger.info("CONFIGURATION DONE")
+
+    ###########################################################################
+    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
+    def _packet_in_handler(self, ev):
+        """
+        Write incoming packets to the pcap file. Flush buffer to avoid pcap
+        entries stuck in write buffer, waiting for the buffer to fill.
+        """
+        msg = ev.msg
+
+        # Dump packet data into PCAP file
+        if self.pcap_writer:
+            self.pcap_writer.write_pkt(msg.data, flush=True)
+
+    ###########################################################################
+    @staticmethod
+    def copy_packets_to_controller(datapath, port=None, vlan_vid=None, ether_type=None):
+        """
+        Configure the switch to copy selected incoming packets to the
+        controller.
+        """
+        fields = {}
+        if port:
+            fields["in_port"] = port
+        if vlan_vid:
+            fields["vlan_vid"] = vlan_vid
+        if ether_type:
+            fields["eth_type"] = ether_type
+        # Default to catching IP traffic
+        if not fields:
+            fields["eth_type"] = ether_types.ETH_TYPE_IP
+
+        ft_60_send_pkt_to_controller.add_entry(
+            datapath, fields=fields, controller_only=False
+        )
+
+    ###########################################################################
+    def create_vpws(self, datapath, plain_port, vlan, vpws_port, vpws_vlan=0):
+        # pylint: disable=too-many-arguments
+        """
+        Create one bidirectional MPLS pseudowire.
+
+        plain_port: port carrying non-MPLS traffic
+        vlan: select traffic on plain_port to send through MPLS pseudowire
+        vpws_port: port attached to MPLS network
+        vpws_lan: vlan to use on vpws_port (default: no VLAN tag)
+        """
+
+        # MPLS labels assigned like this just for demonstration purposes.
+        mpls_label = vlan << 8 | plain_port
+
+        mpls_l2_port_id = create_mpls_l2_port_id(plain_port, vlan)
+        tunnel_id = create_tunnel_id(plain_port, vlan, mpls_l2_port_id)
+
+        # Initiation Groups
+        l2_if_gid = gt_l2_interface.add_entry(datapath, vpws_port, vpws_vlan)
+        mpls_if_gid = gt_mpls_interface.add_entry(
+            datapath, l2_if_gid, vpws_vlan, self.pwc.mac_self, self.pwc.mac_peer
+        )
+        mpls_tunnel_label_gid = gt_mpls_l2_tunnel_label.add_entry(
+            datapath, self.pwc.outer_label_egress, mpls_if_gid
+        )
+        mpls_label_gid = gt_mpls_l2_vpn_label.add_entry(
+            datapath,
+            mpls_label=mpls_label,
+            mpls_group_id=mpls_tunnel_label_gid,
+        )
+
+        # Initiation Flows
+        ft_10_vlan_mpls.add_mpls_entry(
+            datapath, vlan, plain_port, tunnel_id, mpls_l2_port_id
+        )
+        ft_13_mpls_l2_port.add_entry(
+            datapath, mpls_label_gid, tunnel_id, mpls_l2_port_id
+        )
+
+        # Termination Groups
+        l2_unfiltered_if_gid = gt_l2_interface.add_unfiltered_entry(
+            datapath, plain_port
+        )
+
+        # Termination Flows
+        ft_24_drop_outer_label.add_entry(
+            datapath,
+            mpls_label=self.pwc.outer_label_ingress,
+        )
+        ft_24_mpls_pw_terminate.add_entry(
+            datapath,
+            l2_unfiltered_interface_group_id=l2_unfiltered_if_gid,
+            mpls_label=mpls_label,
+            tunnel_id=tunnel_id,
+            mpls_l2_port_id=mpls_l2_port_id,
+        )
+        ft_20_termination.add_entry(datapath, vpws_vlan, self.pwc.mac_self)
+        ft_10_vlan.add_entry(datapath, vpws_port, vpws_vlan)
+
+    ###########################################################################
+    def delete_all_flows(self, datapath):
+        """
+        Delete all flows known to ofagent (in ofagent and on the switch).
+
+        Unlike client_cfg_purge(8), also deletes entries in ofagent. Cannot
+        delete any entries from before an ofagent restart (which wipes
+        the ofagent memory).
+        """
+        send_flow_mod(
+            datapath,
+            command=ofproto.OFPFC_DELETE,
+            table_id=ofproto.OFPTT_ALL,
+            out_group=ofproto.OFPG_ANY,
+            out_port=ofproto.OFPP_ANY,
+        )
+
+        self.logger.info("Deleted all flows.")
+
+    ###########################################################################
+    def delete_all_groups(self, datapath):
+        """
+        Delete all groups known to ofagent (in ofagent and on the switch).
+
+        Unlike client_cfg_purge(8), also deletes entries in ofagent. Cannot
+        delete any entries from before an ofagent restart (which wipes
+        the ofagent memory).
+        """
+        parser = datapath.ofproto_parser
+
+        # Setting type_ to 7 (not a defined type) to demonstrate that it does
+        # not matter: OFPGT_ALL, OFPGT_INDIRECT, and OFPGT_SELECT all seem to
+        # have the same effect; note that OFPGT_ALL is _not_ all types, but
+        # "All (multicast/broadcast) group".
+        group_mod = parser.OFPGroupMod(
+            datapath,
+            command=ofproto.OFPGC_DELETE,
+            type_=7,
+            group_id=ofproto.OFPG_ALL,
+        )
+        datapath.send_msg(group_mod)
+
+        self.logger.info("Deleted all groups.")
-- 
2.35.1

