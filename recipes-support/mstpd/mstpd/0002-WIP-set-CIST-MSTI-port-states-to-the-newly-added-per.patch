From a42c104ada95d1b93a425c876b97217a06ad7160 Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Tue, 26 Jan 2021 10:21:08 +0100
Subject: [PATCH 4/4] WIP: set CIST/MSTI port states to the newly added per
 vlan STP state

Signed-off-by: Jonas Gorski <jonas.gorski@bisdn.de>
---
 bridge_ctl.h   |  12 ++++
 bridge_track.c | 171 +++++++++++++++++++++++++++++++++++++++++++++++--
 bridge_track.h |   1 +
 brmon.c        | 147 +++++++++++++++++++++++++++++++++++++++++-
 mstp.h         |   1 +
 5 files changed, 324 insertions(+), 8 deletions(-)

diff --git a/bridge_ctl.h b/bridge_ctl.h
index d09a8b4..79a415f 100644
--- a/bridge_ctl.h
+++ b/bridge_ctl.h
@@ -31,6 +31,9 @@
 #include <net/if.h>
 #include <linux/if_ether.h>
 
+/* VLAN not present */
+#define VLAN_STATE_UNASSIGNED	0xff
+
 typedef struct
 {
     int if_index;
@@ -48,6 +51,9 @@ typedef struct
 
     bool up;
     int speed, duplex;
+
+    /* current per vlan state */
+    __u8 vlan_state[4095];
 } sysdep_if_data_t;
 
 #define GET_PORT_SPEED(port)    ((port)->sysdeps.speed)
@@ -79,6 +85,8 @@ typedef struct
 
 extern struct rtnl_handle rth_state;
 
+extern bool have_per_vlan_state;
+
 int init_bridge_ops(void);
 
 int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags);
@@ -87,4 +95,8 @@ void bridge_bpdu_rcv(int ifindex, const unsigned char *data, int len);
 
 void bridge_one_second(void);
 
+int vlan_notify(int if_index, bool newvlan, __u16 vid, __u8 state);
+
+int fill_vlan_table(sysdep_if_data_t *if_data);
+
 #endif /* BRIDGE_CTL_H */
diff --git a/bridge_track.c b/bridge_track.c
index 968e15b..d3113ed 100644
--- a/bridge_track.c
+++ b/bridge_track.c
@@ -46,6 +46,7 @@
 #endif
 
 static LIST_HEAD(bridges);
+static LIST_HEAD(ports);
 
 static bridge_t * create_br(int if_index)
 {
@@ -105,11 +106,15 @@ static port_t * create_if(bridge_t * br, int if_index)
         goto err;
     }
 
+    memset(prt->sysdeps.vlan_state, VLAN_STATE_UNASSIGNED, sizeof(prt->sysdeps.vlan_state));
+    fill_vlan_table(&prt->sysdeps);
+
     INFO("Add iface %s as port#%d to bridge %s", prt->sysdeps.name,
          portno, br->sysdeps.name);
     prt->bridge = br;
     if(!MSTP_IN_port_create_and_add_tail(prt, portno))
         goto err;
+    list_add_tail(&prt->list, &ports);
 
     return prt;
 err:
@@ -120,16 +125,28 @@ err:
 static port_t * find_if(bridge_t * br, int if_index)
 {
     port_t *prt;
-    list_for_each_entry(prt, &br->ports, br_list)
+    if (br)
+    {
+        list_for_each_entry(prt, &br->ports, br_list)
+        {
+            if(prt->sysdeps.if_index == if_index)
+                return prt;
+        }
+    }
+    else
     {
-        if(prt->sysdeps.if_index == if_index)
-            return prt;
+        list_for_each_entry(prt, &ports, list)
+        {
+            if(prt->sysdeps.if_index == if_index)
+                return prt;
+        }
     }
     return NULL;
 }
 
 static inline void delete_if(port_t *prt)
 {
+    list_del(&prt->list);
     MSTP_IN_delete_port(prt);
     free(prt);
 }
@@ -184,6 +201,8 @@ static bool check_mac_address(char *name, __u8 *addr)
     }
 }
 
+static int br_set_state(struct rtnl_handle *rth, unsigned ifindex, __u8 state);
+
 static void set_br_up(bridge_t * br, bool up)
 {
     bool changed = false;
@@ -204,9 +223,36 @@ static void set_br_up(bridge_t * br, bool up)
     }
 
     if(changed)
+    {
         MSTP_IN_set_bridge_enable(br, br->sysdeps.up);
+
+        if (have_per_vlan_state)
+        {
+            port_t *prt;
+
+            list_for_each_entry(prt, &br->ports, br_list)
+            {
+	        __u8 state;
+
+                /* when the bridge transitions from down to up, the Linux
+		 * kernel will put all ports into the blocked state.
+		 * This blocks traffic on all vlans, so to make the per vlan
+		 * STP state effective, we will need to put them into forwarding
+		 * again.
+		 */
+		if (up && prt->sysdeps.up)
+                  state = BR_STATE_FORWARDING;
+		else
+                  state = BR_STATE_DISABLED;
+
+                br_set_state(&rth_state,  prt->sysdeps.if_index, state);
+                /* TODO: vlans? */
+            }
+        }
+    }
 }
 
+
 static void set_if_up(port_t *prt, bool up)
 {
     INFO("Port %s : %s", prt->sysdeps.name, (up ? "up" : "down"));
@@ -259,8 +305,12 @@ static void set_if_up(port_t *prt, bool up)
         }
     }
     if(changed)
+    {
         MSTP_IN_set_port_enable(prt, prt->sysdeps.up, prt->sysdeps.speed,
                                 prt->sysdeps.duplex);
+        if (have_per_vlan_state)
+            br_set_state(&rth_state,  prt->sysdeps.if_index, up ? BR_STATE_FORWARDING : BR_STATE_DISABLED);
+    }
 }
 
 /* br_index == if_index means: interface is bridge master */
@@ -347,6 +397,53 @@ int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags)
     return 0;
 }
 
+static int br_set_vlan_state(struct rtnl_handle *rth, unsigned ifindex, __u16 vid, __u8 state);
+
+int vlan_notify(int if_index, bool newvlan, __u16 vid, __u8 state)
+{
+    per_tree_port_t *ptp;
+    bridge_t *br = NULL;
+    port_t *prt = NULL;
+    __u16 fid;
+    __be16 mstid;
+
+    LOG("if_index %d, newvlan %d, vid %d, state %d",
+        if_index, newvlan, vid, state);
+
+    prt = find_if(NULL, if_index);
+    if (!prt)
+        return 0;
+
+    br = prt->bridge;
+    prt->sysdeps.vlan_state[vid] = state;
+
+    /* VLAN was deleted, nothing to do here */
+    if (!newvlan)
+        return 0;
+
+    fid = br->vid2fid[vid];
+    mstid = br->fid2mstid[fid];
+
+    list_for_each_entry(ptp, &prt->trees, port_list)
+    {
+        if (ptp->MSTID == mstid)
+            break;
+    }
+
+    TST(ptp->MSTID == mstid, -1);
+
+    if (ptp->state != state)
+    {
+      if (0 > br_set_vlan_state(&rth_state, if_index, vid, ptp->state))
+      {
+          ERROR_MSTINAME(br, prt, ptp, "VID %i: failed setting STP state %i in kernel", vid, ptp->state);
+          return -1;
+      }
+    }
+
+    return 0;
+}
+
 struct llc_header
 {
     __u8 dest_addr[ETH_ALEN];
@@ -410,6 +507,46 @@ void bridge_bpdu_rcv(int if_index, const unsigned char *data, int len)
                     (bpdu_t *)(data + sizeof(*h)), l - LLC_PDU_LEN_U);
 }
 
+static int br_set_vlan_state(struct rtnl_handle *rth, unsigned ifindex, __u16 vid, __u8 state)
+{
+    struct
+    {
+        struct nlmsghdr n;
+        struct br_vlan_msg bvm;
+        char buf[256];
+    } req;
+    char entry_buf[256];
+    struct rtattr *rta = (void *)entry_buf;
+    struct bridge_vlan_info vlan_info;
+    struct rtattr *nest;
+
+    LOG("ifindex %d vid %d state %d", ifindex, vid, state);
+
+    memset(&req, 0, sizeof(req));
+
+    req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct br_vlan_msg));
+    req.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE;
+    req.n.nlmsg_type = RTM_NEWVLAN;
+    req.bvm.family = AF_BRIDGE;
+    req.bvm.ifindex = ifindex;
+
+    rta->rta_type = BRIDGE_VLANDB_ENTRY;
+    rta->rta_len = RTA_LENGTH(0);
+
+    vlan_info.vid = vid;
+    vlan_info.flags = BRIDGE_VLAN_INFO_ONLY_OPTS;
+
+    nest = rta_nest(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY);
+    rta_addattr_l(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY_INFO, &vlan_info, sizeof(vlan_info));
+    rta_addattr8(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY_STATE, state);
+
+    rta_nest_end(rta, nest);
+
+    addraw_l(&req.n, sizeof(req.buf), RTA_DATA(rta), RTA_PAYLOAD(rta));
+
+    return rtnl_talk(rth, &req.n, 0, 0, NULL, NULL, NULL);
+}
+
 static int br_set_state(struct rtnl_handle *rth, unsigned ifindex, __u8 state)
 {
     struct
@@ -419,6 +556,8 @@ static int br_set_state(struct rtnl_handle *rth, unsigned ifindex, __u8 state)
         char buf[256];
     } req;
 
+    LOG("ifindex %d state %d", ifindex, state);
+
     memset(&req, 0, sizeof(req));
 
     req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
@@ -493,9 +632,29 @@ void MSTP_OUT_set_state(per_tree_port_t *ptp, int new_state)
     }
     INFO_MSTINAME(br, prt, ptp, "entering %s state", state_name);
 
-    /* Translate new CIST state to the kernel bridge code */
-    if(0 == ptp->MSTID)
-    { /* CIST */
+    if(have_per_vlan_state)
+    {
+        int i;
+
+        for (i = 1; i <= MAX_VID; i++)
+        {
+            __u16 fid = br->vid2fid[i];
+
+            if (br->fid2mstid[fid] != ptp->MSTID)
+                continue;
+
+            if (prt->sysdeps.vlan_state[i] == VLAN_STATE_UNASSIGNED)
+                continue;
+
+            if(0 > br_set_vlan_state(&rth_state, prt->sysdeps.if_index, i, ptp->state))
+               ERROR_PRTNAME(br, prt, "Couldn't set kernel bridge state %s for vid %i",
+                             state_name, i);
+            prt->sysdeps.vlan_state[i] = new_state;
+        }
+    }
+    else if(0 == ptp->MSTID)
+    {
+        /* Translate new CIST state to the kernel bridge code */
         if(0 > br_set_state(&rth_state, prt->sysdeps.if_index, ptp->state))
             ERROR_PRTNAME(br, prt, "Couldn't set kernel bridge state %s",
                           state_name);
diff --git a/bridge_track.h b/bridge_track.h
index d3aec99..a1083fa 100644
--- a/bridge_track.h
+++ b/bridge_track.h
@@ -21,6 +21,7 @@
 #ifndef MSTPD_BRIDGE_TRACK_H
 #define MSTPD_BRIDGE_TRACK_H
 
+
 int bridge_track_fini(void);
 
 #endif
diff --git a/brmon.c b/brmon.c
index aa7e3b7..16b9cb7 100644
--- a/brmon.c
+++ b/brmon.c
@@ -17,6 +17,7 @@
 #include <stdlib.h>
 #include <fcntl.h>
 #include <netinet/in.h>
+#include <string.h>
 #include <linux/if_bridge.h>
 
 #include "log.h"
@@ -58,8 +59,10 @@ static struct epoll_event_handler br_handler;
 
 struct rtnl_handle rth_state;
 
-static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
-                    void *arg)
+bool have_per_vlan_state = 1;
+
+static int dump_br_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                       void *arg)
 {
     struct ifinfomsg *ifi = NLMSG_DATA(n);
     struct rtattr * tb[IFLA_MAX + 1];
@@ -166,6 +169,140 @@ static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
     return 0;
 }
 
+static int dump_vlan_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                         void *arg)
+{
+    struct br_vlan_msg *bvm = NLMSG_DATA(n);
+    struct rtattr *pos;
+    int len = n->nlmsg_len;
+    bool newvlan = n->nlmsg_type == RTM_NEWVLAN;
+
+    for (pos = NLMSG_DATA(n) + NLMSG_ALIGN(sizeof(*bvm)); RTA_OK(pos, len); pos = RTA_NEXT(pos, len))
+    {
+        struct rtattr *tb[BRIDGE_VLANDB_ENTRY_MAX +1];
+        struct bridge_vlan_info *info = NULL;
+        uint8_t state = VLAN_STATE_UNASSIGNED;
+        uint16_t range = 0;
+        uint16_t i;
+
+        if ((pos->rta_type & NLA_TYPE_MASK) != BRIDGE_VLANDB_ENTRY)
+            continue;
+
+        parse_rtattr_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, pos);
+
+        if (tb[BRIDGE_VLANDB_ENTRY_INFO])
+            info = RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_INFO]);
+        if (tb[BRIDGE_VLANDB_ENTRY_STATE])
+            state = *(uint8_t *)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_STATE]);
+        if (tb[BRIDGE_VLANDB_ENTRY_RANGE])
+            range = *(uint16_t*)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+        if (!info)
+            continue;
+
+        if (!range)
+            range = info->vid;
+
+        for (i = info->vid;  i <= range; i++)
+            vlan_notify(bvm->ifindex, newvlan, i, state);
+    }
+
+    return 0;
+}
+
+struct vlan_dump_table {
+    int if_index;
+    uint8_t *table;
+};
+
+static int vlan_table_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                          void *arg)
+{
+    struct br_vlan_msg *bvm = NLMSG_DATA(n);
+    struct rtattr *pos;
+    int len = n->nlmsg_len;
+    sysdep_if_data_t *if_data = arg;
+
+    if (bvm->ifindex != if_data->if_index)
+            return 0;
+
+    for (pos = NLMSG_DATA(n) + NLMSG_ALIGN(sizeof(*bvm)); RTA_OK(pos, len); pos = RTA_NEXT(pos, len))
+    {
+        struct rtattr *tb[BRIDGE_VLANDB_ENTRY_MAX +1];
+        struct bridge_vlan_info *info = NULL;
+        uint8_t state = VLAN_STATE_UNASSIGNED;
+        uint16_t range = 0;
+        uint16_t i;
+
+        if ((pos->rta_type & NLA_TYPE_MASK) != BRIDGE_VLANDB_ENTRY)
+            continue;
+
+        parse_rtattr_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, pos);
+
+        if (tb[BRIDGE_VLANDB_ENTRY_INFO])
+            info = RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_INFO]);
+        if (tb[BRIDGE_VLANDB_ENTRY_STATE])
+            state = *(uint8_t *)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_STATE]);
+        if (tb[BRIDGE_VLANDB_ENTRY_RANGE])
+            range = *(uint16_t*)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+        if (!info)
+            continue;
+
+        if (!range)
+            range = info->vid;
+
+        for (i = info->vid; i <= range; i++)
+            if_data->vlan_state[i] = state;
+    }
+
+    return 0;
+}
+
+static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                    void *arg)
+{
+    switch (n->nlmsg_type)
+    {
+        case RTM_NEWLINK:
+        case RTM_DELLINK:
+            return dump_br_msg(who, n, arg);
+        case RTM_NEWVLAN:
+        case RTM_DELVLAN:
+            return dump_vlan_msg(who, n, arg);
+        default:
+            return 0;
+    }
+}
+
+int fill_vlan_table(sysdep_if_data_t *if_data)
+{
+    struct br_vlan_msg bvm = {
+        .family = PF_BRIDGE,
+     /* .ifindex = if_data->if_index, */
+    };
+
+    if(!have_per_vlan_state)
+        return 0;
+
+    /* For unknown reason setting ifindex to non-zero will cause the kernel
+     * to flood us with the same message over and over again, so filter
+     * within mstpd for now */
+    if(rtnl_dump_request(&rth, RTM_GETVLAN, &bvm, sizeof(bvm)) < 0)
+    {
+        ERROR("Cannot send dump request: %m\n");
+        return -1;
+    }
+
+    if(rtnl_dump_filter(&rth, vlan_table_msg, if_data, NULL, NULL) < 0)
+    {
+        ERROR("Dump terminated\n");
+        return -1;
+    }
+
+    return 0;
+}
+
 static inline void br_ev_handler(uint32_t events, struct epoll_event_handler *h)
 {
     if(rtnl_listen(&rth, dump_msg, stdout) < 0)
@@ -182,6 +319,12 @@ int init_bridge_ops(void)
         return -1;
     }
 
+    if(rtnl_add_nl_group(&rth, RTNLGRP_BRVLAN) < 0)
+    {
+        ERROR("Couldn't join RTNLGRP_BRVLAN, per vlan STP state not available\n");
+        have_per_vlan_state = 0;
+    }
+
     if(rtnl_open(&rth_state, 0) < 0)
     {
         ERROR("Couldn't open rtnl socket for setting state\n");
diff --git a/mstp.h b/mstp.h
index 983fd55..7bbdfff 100644
--- a/mstp.h
+++ b/mstp.h
@@ -443,6 +443,7 @@ typedef struct
 typedef struct
 {
     struct list_head br_list; /* anchor in bridge's list of ports */
+    struct list_head list; /* list of all interfaces */
     bridge_t * bridge;
     __be16 port_number;
 
-- 
2.30.0

