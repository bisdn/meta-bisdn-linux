From 9bc807c1eec3cd5e51457cb954b0ea0ade5e2523 Mon Sep 17 00:00:00 2001
From: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
Date: Tue, 5 Jan 2021 19:35:12 +0100
Subject: [PATCH] bridge-vlan-db: add support for bridge-vlan notifications

 * Support parsing objects; export symbols
 * Add free function
 * Expose api
 * Send correct message to kernel; implement helper functions
 * Add bridge_vlan entry parameter; nl-bridge: output result
 * Add msg type to object
 * Refactor bridge vlan getters/setters

Signed-off-by: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
---
 Makefile.am                         |   6 +
 include/netlink-private/types.h     |  22 ++
 include/netlink/cli/bridge_vlan.h   |  23 ++
 include/netlink/cli/utils.h         |   3 +
 include/netlink/route/bridge_vlan.h |  40 +++
 lib/route/bridge_vlan.c             | 373 +++++++++++++++++++++++++++-
 libnl-cli-3.sym                     |   6 +
 libnl-route-3.sym                   |  12 +
 src/lib/bridge_vlan.c               |  42 ++++
 src/lib/utils.c                     |  10 +
 src/nl-bridge.c                     |  38 +++
 src/nl-monitor.c                    |   4 +-
 12 files changed, 575 insertions(+), 4 deletions(-)
 create mode 100644 include/netlink/cli/bridge_vlan.h
 create mode 100644 include/netlink/route/bridge_vlan.h
 create mode 100644 src/lib/bridge_vlan.c
 create mode 100644 src/nl-bridge.c

diff --git a/Makefile.am b/Makefile.am
index e472bbb..d53e6d1 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -102,6 +102,7 @@ libnlinclude_netlink_routedir = $(libnlincludedir)/netlink/route
 libnlinclude_netlink_route_HEADERS = \
 	include/netlink/route/action.h \
 	include/netlink/route/addr.h \
+	include/netlink/route/bridge_vlan.h \
 	include/netlink/route/class.h \
 	include/netlink/route/classifier.h \
 	include/netlink/route/link.h \
@@ -199,6 +200,7 @@ if ENABLE_CLI
 libnlinclude_netlink_clidir = $(libnlincludedir)/netlink/cli
 libnlinclude_netlink_cli_HEADERS = \
 	include/netlink/cli/addr.h \
+	include/netlink/cli/bridge_vlan.h \
 	include/netlink/cli/class.h \
 	include/netlink/cli/cls.h \
 	include/netlink/cli/ct.h \
@@ -611,6 +613,7 @@ endif
 
 src_lib_libnl_cli_3_la_SOURCES = \
 	src/lib/addr.c \
+	src/lib/bridge_vlan.c \
 	src/lib/class.c \
 	src/lib/cls.c \
 	src/lib/ct.c \
@@ -678,6 +681,7 @@ cli_programs = \
 	src/nl-addr-add \
 	src/nl-addr-delete \
 	src/nl-addr-list \
+	src/nl-bridge \
 	src/nl-class-add \
 	src/nl-class-delete \
 	src/nl-class-list \
@@ -755,6 +759,8 @@ src_nl_addr_delete_CPPFLAGS =       $(src_cppflags)
 src_nl_addr_delete_LDADD =          $(src_ldadd)
 src_nl_addr_list_CPPFLAGS =         $(src_cppflags)
 src_nl_addr_list_LDADD =            $(src_ldadd)
+src_nl_bridge_CPPFLAGS =       	    $(src_cppflags)
+src_nl_bridge_LDADD =          	    $(src_ldadd)
 src_nl_class_add_CPPFLAGS =         $(src_cppflags)
 src_nl_class_add_LDADD =            $(src_ldadd)
 src_nl_class_delete_CPPFLAGS =      $(src_cppflags)
diff --git a/include/netlink-private/types.h b/include/netlink-private/types.h
index eec2e83..4e42c77 100644
--- a/include/netlink-private/types.h
+++ b/include/netlink-private/types.h
@@ -1358,4 +1358,26 @@ struct rtnl_mdb_entry {
 
 	struct nl_list_head mdb_list;
 };
+
+struct rtnl_bvlan_entry {
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_entry_list;
+};
+
+struct rtnl_bridge_vlan {
+	NLHDR_COMMON
+	uint32_t ifindex;
+	uint8_t family;
+
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_list;
+};
 #endif
diff --git a/include/netlink/cli/bridge_vlan.h b/include/netlink/cli/bridge_vlan.h
new file mode 100644
index 0000000..8d3adbd
--- /dev/null
+++ b/include/netlink/cli/bridge_vlan.h
@@ -0,0 +1,23 @@
+/*
+ * netlink/cli/link.h     CLI Link Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_BVLAN_H_
+#define __NETLINK_CLI_BVLAN_H_
+
+#include <netlink/route/link.h>
+#include <netlink/cli/utils.h>
+
+extern struct rtnl_bridge_vlan *nl_cli_bridge_vlan_alloc(void);
+extern struct nl_cache *nl_cli_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+						unsigned int flags);
+void nl_cli_bridge_vlan_parse_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex);
+
+#endif
diff --git a/include/netlink/cli/utils.h b/include/netlink/cli/utils.h
index 7d69543..a49e1f6 100644
--- a/include/netlink/cli/utils.h
+++ b/include/netlink/cli/utils.h
@@ -81,6 +81,9 @@ extern struct nl_cache *nl_cli_alloc_cache_flags(struct nl_sock *, const char *,
 
 extern void		nl_cli_load_module(const char *, const char *);
 
+void nl_cli_socket_enable_auto_ack(struct nl_sock *sk);
+void nl_cli_socket_disable_auto_ack(struct nl_sock *sk);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/netlink/route/bridge_vlan.h b/include/netlink/route/bridge_vlan.h
new file mode 100644
index 0000000..467fcbb
--- /dev/null
+++ b/include/netlink/route/bridge_vlan.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+
+#ifndef NETLINK_B_VLAN_H_
+#define NETLINK_B_VLAN_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void);
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache, int ifindex);
+	void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk,
+					 struct nl_cache **result);
+	int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+					       struct nl_cache **result,
+					       unsigned int flags);
+	int rtnl_bridge_vlan_change(struct nl_sock *sk, struct rtnl_bridge_vlan *orig,
+			     struct rtnl_bridge_vlan *changes, int flags);
+	int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig,
+						  struct rtnl_bridge_vlan *changes, int flags,
+						  struct nl_msg **result);
+	int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex);
+
+	struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void);
+	void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan, struct rtnl_bvlan_entry *entry);
+  void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+      void (*cb)(struct rtnl_bvlan_entry *, void *), void *arg);
+  struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct rtnl_bridge_vlan *obj);
+  int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan);
+  int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan, uint16_t vid);
+  uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry *bvlan);
+  int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan, uint8_t state);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/lib/route/bridge_vlan.c b/lib/route/bridge_vlan.c
index df4a615..1632b5f 100644
--- a/lib/route/bridge_vlan.c
+++ b/lib/route/bridge_vlan.c
@@ -1,29 +1,198 @@
 /* SPDX-License-Identifier: LGPL-2.1-only */
 /*
- * lib/route/mdb.c		Multicast Database
+ * lib/route/bridge_vlan.c		Bridge VLAN database
  */
 
 #include <netlink-private/netlink.h>
+#include <netlink/route/bridge_vlan.h>
 #include <netlink/netlink.h>
 #include <linux/if_bridge.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define BRIDGE_VLAN_ATTR_IFINDEX         0x000001
+#define BRIDGE_VLAN_ATTR_RANGE           0x000002
+#define BRIDGE_VLAN_ATTR_FAMILY          0x000004
+#define BRIDGE_VLAN_ATTR_VID             0x000008
 
 static struct nl_cache_ops rtnl_bridge_vlan_ops;
 static struct nl_object_ops bridge_vlan_obj_ops;
 /** @endcond */
 
-static int bridge_vlan_request_update(struct nl_cache *cache, struct nl_sock *sk)
+static void bridge_vlan_constructor(struct nl_object *obj)
+{
+	struct rtnl_bridge_vlan *_bridge_vlan = (struct rtnl_bridge_vlan *) obj;
+
+	nl_init_list_head(&_bridge_vlan->bridge_vlan_list);
+}
+
+static void bvlan_entry_free_data(struct rtnl_bvlan_entry *entry)
+{
+	free(entry);
+}
+
+static void bridge_vlan_free_data(struct nl_object *obj)
 {
+	struct rtnl_bridge_vlan *bvlan = (struct rtnl_bridge_vlan *) obj;
+	struct rtnl_bvlan_entry *bvlan_entry;
+
+//	nl_list_for_each_entry(bvlan_entry, &bvlan->bridge_vlan_list, bridge_vlan_entry_list)
+//	    bvlan_entry_free_data(bvlan_entry);
+}
+
+static uint64_t bridge_vlan_compare(struct nl_object *_a, struct nl_object *_b,
+				  uint64_t attrs, int flags)
+{
+	struct rtnl_bridge_vlan *a = (struct rtnl_bridge_vlan *) _a;
+	struct rtnl_bridge_vlan *b = (struct rtnl_bridge_vlan *) _b;
+	uint64_t diff = 0;
+
+#if 0
+#define BRIDGE_VLAN_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, BRIDGE_VLAN_ATTR_##ATTR, a, b, EXPR)
+	diff |= BRIDGE_VLAN_DIFF(IFINDEX, a->ifindex != b->ifindex);
+#undef BRIDGE_VLAN_DIFF
+#endif
+	return 1;
+}
+
+static int bridge_vlan_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_bridge_vlan *dst = nl_object_priv(_dst);
+	struct rtnl_bridge_vlan *src = nl_object_priv(_src);
+
+	dst->ifindex = src->ifindex;
+	dst->family = src->family;
+	dst->state = src->state;
+	dst->vlan_id = src->vlan_id;
+	dst->range = src->range;
+
 	return 0;
 }
 
+static int bridge_vlan_update(struct nl_object *old_obj, struct nl_object *new_obj)
+{
+	struct rtnl_bridge_vlan *old = (struct rtnl_bridge_vlan *) old_obj;
+	struct rtnl_bridge_vlan *new = (struct rtnl_bridge_vlan *) new_obj;
+
+	return NLE_SUCCESS;
+}
+
+static void brvlan_entry_dump_line(struct rtnl_bvlan_entry *entry, struct nl_dump_params *p)
+{
+	nl_dump(p, " VLAN=%d", entry->vlan_id);
+	nl_dump(p, " State=%d\n", entry->state);
+
+	if (entry->range)
+		nl_dump(p, "RANGE=%d\n", entry->range);
+}
+
+static void br_vlan_dump_line(struct nl_object *_obj, struct nl_dump_params *p)
+{
+	struct rtnl_bridge_vlan *obj = (struct rtnl_bridge_vlan *) _obj;
+	struct rtnl_bvlan_entry *entry;
+
+	nl_dump(p, "Ifindex=%d:\n", obj->ifindex);
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list, bridge_vlan_entry_list) {
+		brvlan_entry_dump_line(entry, p);
+	}
+}
+
+static int bridge_vlan_request_update(struct nl_cache *cache, struct nl_sock *sk)
+{
+	int err;
+	struct br_vlan_msg gmsg = {
+		.family = AF_BRIDGE,
+	};
+
+	err = nl_send_simple(sk, RTM_GETVLAN, NLM_F_DUMP, &gmsg, sizeof(gmsg));
+	return err >= 0 ? 0 : err;
+}
+
+static struct nla_policy br_vlandb_policy[BRIDGE_VLANDB_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY] = {.type = NLA_NESTED},
+};
+
+static struct nla_policy br_vlandb_entry_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY_INFO]	= { .type = NLA_BINARY, 
+					    .minlen = sizeof(struct bridge_vlan_info),
+					    .maxlen = sizeof(struct bridge_vlan_info) },
+	[BRIDGE_VLANDB_ENTRY_RANGE]	= { .type = NLA_U16 },
+	[BRIDGE_VLANDB_ENTRY_STATE]	= { .type = NLA_U8 },
+	[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = { .type = NLA_NESTED },
+};
+
 static int bridge_vlan_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
 			  struct nlmsghdr *nlh, struct nl_parser_param *pp)
 {
-	return 0;
+	int err = 0;
+	struct nlattr *tb[BRIDGE_VLANDB_MAX + 1], *ttb[BRIDGE_VLANDB_ENTRY_MAX + 1];
+	uint8_t state = 0;
+	uint16_t range = 0;
+	struct bridge_vlan_info *bvlan_info = NULL;
+	struct rtnl_bridge_vlan *bvlan = rtnl_bridge_vlan_alloc();
+	struct br_vlan_msg *bmsg = nlmsg_data(nlh);
+
+	err = nlmsg_parse(nlh, sizeof(struct br_vlan_msg), tb, BRIDGE_VLANDB_MAX,
+			  br_vlandb_policy);
+	if (err < 0)
+		goto errout;
+
+	struct nlattr *pos;
+	int rem = nlh->nlmsg_len;
+
+	bvlan->ce_msgtype = nlh->nlmsg_type;
+
+	bvlan->ifindex = bmsg->ifindex;
+	bvlan->family = bmsg->family;
+	for (pos = nlmsg_data(nlh); nla_ok(pos, rem); pos = nla_next(pos, &rem)) {
+		if (nla_type(pos) != BRIDGE_VLANDB_ENTRY)
+			continue;
+
+		struct rtnl_bvlan_entry *_bvlan = rtnl_bvlan_entry_alloc();
+
+		nla_parse_nested(ttb, BRIDGE_VLANDB_ENTRY_MAX, pos, br_vlandb_entry_policy);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_INFO])
+			bvlan_info = nla_data(ttb[BRIDGE_VLANDB_ENTRY_INFO]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_STATE])
+			state = nla_get_u8(ttb[BRIDGE_VLANDB_ENTRY_STATE]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_RANGE])
+			range = nla_get_u16(ttb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+		_bvlan->state = state;
+		_bvlan->flags = bvlan_info->flags;
+		_bvlan->vlan_id = bvlan_info->vid;
+		_bvlan->range = range;
+
+		rtnl_bridge_vlan_add_entry(bvlan, _bvlan);
+	}
+
+	err = pp->pp_cb((struct nl_object *) bvlan, pp);
+errout:
+	rtnl_bridge_vlan_put(bvlan);
+	return err;
 }
 
+static struct nl_af_group br_vlan_groups[] = {
+	{AF_BRIDGE, RTNLGRP_BRVLAN},
+	{END_OF_GROUP_LIST},
+};
+
 static struct nl_object_ops bridge_vlan_obj_ops = {
 	.oo_name = "route/bridgevlan",
+	.oo_size = sizeof(struct rtnl_bridge_vlan),
+	.oo_dump = {
+		    [NL_DUMP_LINE] = br_vlan_dump_line,
+		    [NL_DUMP_DETAILS] = br_vlan_dump_line,
+		    [NL_DUMP_STATS] = br_vlan_dump_line,
+		    },
+	.oo_constructor = bridge_vlan_constructor,
+	.oo_compare = bridge_vlan_compare,
+	.oo_clone = bridge_vlan_clone,
+	.oo_update = bridge_vlan_update,
+	.oo_free_data = bridge_vlan_free_data,
 };
 
 static struct nl_cache_ops bridge_vlan_ops = {
@@ -36,11 +205,209 @@ static struct nl_cache_ops bridge_vlan_ops = {
 			END_OF_MSGTYPES_LIST,
 			},
 	.co_protocol = NETLINK_ROUTE,
+	.co_groups = br_vlan_groups,
 	.co_request_update = bridge_vlan_request_update,
 	.co_msg_parser = bridge_vlan_msg_parser,
 	.co_obj_ops = &bridge_vlan_obj_ops,
 };
 
+/**
+ * @name Cache Management
+ * @{
+ */
+int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&bridge_vlan_ops, sk, result);
+}
+
+/**
+ * Build a bridge vlan cache including all Bridge VLAN entries currently configured in the kernel.
+ * @arg sock		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ * @arg flags		Flags to apply to cache before filling
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock, struct nl_cache **result,
+			       unsigned int flags)
+{
+	struct nl_cache *cache;
+	int err;
+
+	cache = nl_cache_alloc(&bridge_vlan_ops);
+	if (!cache)
+		return -NLE_NOMEM;
+
+	nl_cache_set_flags(cache, flags);
+
+	if (sock && (err = nl_cache_refill(sock, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+/** @} */
+
+/**
+ * @name Add / Modify
+ * @{
+ */
+
+static int build_bridge_vlan_msg(int cmd, struct br_vlan_msg *hdr,
+			  	 struct rtnl_bridge_vlan *link, int flags, struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	*result = msg;
+	return 0;
+}
+
+int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig,
+				   	  struct rtnl_bridge_vlan *changes, int flags,
+				   	  struct nl_msg **result)
+{
+	struct br_vlan_msg bvlan = {
+		.family = orig->family,
+		.ifindex = orig->ifindex,
+	};
+	int err, rt;
+
+	build_bridge_vlan_msg(RTM_SETLINK, &bvlan, changes, flags, result);
+
+	return 0;
+}
+
+int rtnl_bridge_vlan_change(struct nl_sock *sk, struct rtnl_bridge_vlan *orig,
+		     struct rtnl_bridge_vlan *changes, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	err = rtnl_bridge_vlan_build_change_request(orig, changes, flags, &msg);
+
+	BUG_ON(msg->nm_nlh->nlmsg_seq != NL_AUTO_SEQ);
+retry:
+	err = nl_send_auto_complete(sk, msg);
+	if (err < 0)
+		goto errout;
+
+	err = wait_for_ack(sk);
+	if (err == -NLE_OPNOTSUPP && msg->nm_nlh->nlmsg_type == RTM_NEWLINK) {
+		msg->nm_nlh->nlmsg_type = RTM_SETLINK;
+		msg->nm_nlh->nlmsg_seq = NL_AUTO_SEQ;
+		goto retry;
+	}
+
+errout:
+	nlmsg_free(msg);
+	return err;
+}
+/** @} */
+
+/**
+ * @name Get/ Set
+ * @{
+ */
+void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan, struct rtnl_bvlan_entry *entry)
+{
+	nl_list_add_tail(&entry->bridge_vlan_entry_list, &bvlan->bridge_vlan_list);
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache, int ifindex)
+{
+	struct rtnl_bridge_vlan *bvlan_entry;
+
+	if (cache->c_ops != &rtnl_bridge_vlan_ops)
+		return NULL;
+
+	nl_list_for_each_entry(bvlan_entry, &cache->c_items, ce_list) {
+		if (bvlan_entry->ifindex == ifindex) {
+			nl_object_get((struct nl_object *) bvlan_entry);
+			return bvlan_entry;
+		}
+	}
+
+	return NULL;
+
+}
+
+struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct rtnl_bridge_vlan *obj) 
+{
+			return nl_list_first_entry(&obj->bridge_vlan_list, struct rtnl_bvlan_entry, bridge_vlan_entry_list);
+
+}
+
+void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+			    void (*cb)(struct rtnl_bvlan_entry *, void *),
+			    void *arg)
+{
+	struct rtnl_bvlan_entry *entry;
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list, bridge_vlan_entry_list) {
+		cb(entry, arg);
+	}
+}
+
+int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan)
+{
+	return bvlan->ifindex;
+}
+
+int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex)
+{
+	bvlan->ifindex = ifindex;
+	return 0;
+}
+
+int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->vlan_id;
+}
+
+int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan, uint16_t vid)
+{
+	bvlan->vlan_id = vid;
+	return 0;
+}
+
+uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->state;
+}
+
+int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan, uint8_t state)
+{
+	bvlan->state = state;
+	return 0;
+}
+/** @} */
+
+struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void)
+{
+	struct rtnl_bvlan_entry *entry;
+
+	entry = calloc(1, sizeof(struct rtnl_bvlan_entry));
+	if (!entry)
+		return NULL;
+	return entry;
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void)
+{
+	return (struct rtnl_bridge_vlan *) nl_object_alloc(&bridge_vlan_obj_ops);
+}
+
+
+void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan)
+{
+	nl_object_put((struct nl_object *) bvlan);
+
+}
+
 static void __init bridge_vlan_init(void)
 {
 	nl_cache_mngt_register(&bridge_vlan_ops);
diff --git a/libnl-cli-3.sym b/libnl-cli-3.sym
index 71ff2eb..dbdd64f 100644
--- a/libnl-cli-3.sym
+++ b/libnl-cli-3.sym
@@ -111,7 +111,13 @@ local:
 
 libnl_3_2_28 {
 global:
+	nl_cli_socket_enable_auto_ack;
+	nl_cli_socket_disable_auto_ack;
 	nl_cli_alloc_cache_flags;
 	nl_cli_link_alloc_cache_flags;
 	nl_cli_link_alloc_cache_family_flags;
+	nl_cli_bridge_vlan_alloc;
+	nl_cli_bridge_vlan_alloc_cache_flags;
+	nl_cli_bridge_vlan_parse_ifindex;
 } libnl_3;
+
diff --git a/libnl-route-3.sym b/libnl-route-3.sym
index dc89700..17884e4 100644
--- a/libnl-route-3.sym
+++ b/libnl-route-3.sym
@@ -1172,4 +1172,16 @@ libnl_3_6 {
 	rtnl_mdb_entry_get_proto;
 	rtnl_mdb_entry_get_state;
 	rtnl_mdb_entry_get_vid;
+	rtnl_bridge_vlan_alloc;
+	rtnl_bridge_vlan_alloc_cache;
+	rtnl_bridge_vlan_alloc_cache_flags;
+	rtnl_bridge_vlan_get_ifindex;
+	rtnl_bridge_vlan_set_ifindex;
+  rtnl_bridge_vlan_entry_get_vlan_id;
+  rtnl_bridge_vlan_entry_set_vlan_id;
+  rtnl_bridge_vlan_entry_get_state;
+  rtnl_bridge_vlan_add_entry;
+  rtnl_bridge_vlan_foreach_entry;
+  rtnl_bridge_vlan_get_entry_head;
 } libnl_3_5;
+
diff --git a/src/lib/bridge_vlan.c b/src/lib/bridge_vlan.c
new file mode 100644
index 0000000..7f90a7f
--- /dev/null
+++ b/src/lib/bridge_vlan.c
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * src/lib/bridge_vlan.c     CLI Link Helpers
+ *
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_bridge_vlan Bridge Vlan
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/bridge_vlan.h>
+#include <linux/if_bridge.h>
+#include <netlink/route/bridge_vlan.h>
+
+struct rtnl_bridge_vlan *nl_cli_bridge_vlan_alloc(void)
+{
+	struct rtnl_bridge_vlan *bvlan;
+
+	bvlan = rtnl_bridge_vlan_alloc();
+	if (!bvlan)
+		nl_cli_fatal(ENOMEM, "Unable to allocate bridge-vlan object");
+
+	return bvlan;
+}
+
+struct nl_cache *nl_cli_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+						unsigned int flags)
+{
+	struct nl_cache *cache;
+	rtnl_bridge_vlan_alloc_cache_flags(sock, &cache, flags);
+
+	return cache;
+}
+
+void nl_cli_bridge_vlan_parse_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex)
+{
+	rtnl_bridge_vlan_set_ifindex(bvlan, ifindex);
+}
diff --git a/src/lib/utils.c b/src/lib/utils.c
index 3aa2a90..820983a 100644
--- a/src/lib/utils.c
+++ b/src/lib/utils.c
@@ -133,6 +133,16 @@ struct nl_sock *nl_cli_alloc_socket(void)
 	return sock;
 }
 
+
+void nl_cli_socket_enable_auto_ack(struct nl_sock *sk)
+{
+	nl_socket_enable_auto_ack(sk);
+}
+void nl_cli_socket_disable_auto_ack(struct nl_sock *sk)
+{
+	nl_socket_disable_auto_ack(sk);
+}
+
 struct nl_addr *nl_cli_addr_parse(const char *str, int family)
 {
 	struct nl_addr *addr;
diff --git a/src/nl-bridge.c b/src/nl-bridge.c
new file mode 100644
index 0000000..32530fe
--- /dev/null
+++ b/src/nl-bridge.c
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * src/nl-bridge.c     Bridge utility
+ */
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/cli/utils.h>
+#include <netlink/cli/bridge_vlan.h>
+#include <netlink/cli/link.h>
+
+#include <netlink-private/cache-api.h>
+#include <linux/netlink.h>
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_link *bridge;
+	struct rtnl_bridge_vlan *bvlan = nl_cli_bridge_vlan_alloc();
+	struct nl_cache *bvlan_cache;
+	int err;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_DETAILS,
+		.dp_fd = stdout,
+	};
+
+	struct nl_cache_mngr *mngr;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	bvlan_cache = nl_cli_bridge_vlan_alloc_cache_flags(sock, NL_CACHE_AF_ITER);
+
+	nl_cache_dump(bvlan_cache, &dp);
+
+	printf("end\n");
+
+	return 0;
+}
diff --git a/src/nl-monitor.c b/src/nl-monitor.c
index 99aa0f4..e06c006 100644
--- a/src/nl-monitor.c
+++ b/src/nl-monitor.c
@@ -38,6 +38,7 @@ static const struct {
 	{ RTNLGRP_IPV6_NETCONF, "ipv6-netconf" },
 	{ RTNLGRP_MPLS_NETCONF, "mpls-netconf" },
 	{ RTNLGRP_MDB, "mdb" },
+	{ RTNLGRP_BRVLAN, "bridge-vlan" },
 	{ RTNLGRP_NONE, NULL }
 };
 
@@ -48,6 +49,7 @@ static void obj_input(struct nl_object *obj, void *arg)
 
 static int event_input(struct nl_msg *msg, void *arg)
 {
+	nl_msg_dump(msg, stdout);
 	if (nl_msg_parse(msg, &obj_input, arg) < 0)
 		fprintf(stderr, "<<EVENT>> Unknown message type\n");
 
@@ -77,7 +79,7 @@ static void print_usage(void)
 int main(int argc, char *argv[])
 {
 	struct nl_dump_params dp = {
-		.dp_type = NL_DUMP_STATS,
+		.dp_type = NL_DUMP_LINE,
 		.dp_fd = stdout,
 		.dp_dump_msgtype = 1,
 	};
-- 
2.26.2

