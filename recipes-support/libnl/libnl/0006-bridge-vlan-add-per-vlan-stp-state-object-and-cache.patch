From e956c28b0020946b8696e979d095b8ec3c7a3917 Mon Sep 17 00:00:00 2001
From: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
Date: Tue, 10 Aug 2021 11:23:39 +0200
Subject: [PATCH 6/6] bridge-vlan: add per vlan stp state object and cache

Signed-off-by: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
---
 Makefile.am                         |   7 +
 include/netlink-private/types.h     |  24 ++
 include/netlink/cli/bridge_vlan.h   |  23 ++
 include/netlink/route/bridge_vlan.h |  51 ++++
 lib/route/bridge_vlan.c             | 444 ++++++++++++++++++++++++++++
 libnl-cli-3.sym                     |   3 +
 libnl-route-3.sym                   |  11 +
 src/lib/bridge_vlan.c               |  42 +++
 src/nl-bridge.c                     |  38 +++
 src/nl-monitor.c                    |   1 +
 10 files changed, 644 insertions(+)
 create mode 100644 include/netlink/cli/bridge_vlan.h
 create mode 100644 include/netlink/route/bridge_vlan.h
 create mode 100644 lib/route/bridge_vlan.c
 create mode 100644 src/lib/bridge_vlan.c
 create mode 100644 src/nl-bridge.c

diff --git a/Makefile.am b/Makefile.am
index 1d70059..77d796c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -102,6 +102,7 @@ libnlinclude_netlink_routedir = $(libnlincludedir)/netlink/route
 libnlinclude_netlink_route_HEADERS = \
 	include/netlink/route/action.h \
 	include/netlink/route/addr.h \
+	include/netlink/route/bridge_vlan.h \
 	include/netlink/route/class.h \
 	include/netlink/route/classifier.h \
 	include/netlink/route/link.h \
@@ -199,6 +200,7 @@ if ENABLE_CLI
 libnlinclude_netlink_clidir = $(libnlincludedir)/netlink/cli
 libnlinclude_netlink_cli_HEADERS = \
 	include/netlink/cli/addr.h \
+	include/netlink/cli/bridge_vlan.h \
 	include/netlink/cli/class.h \
 	include/netlink/cli/cls.h \
 	include/netlink/cli/ct.h \
@@ -376,6 +378,7 @@ lib_libnl_route_3_la_SOURCES = \
 	lib/route/act/skbedit.c \
 	lib/route/act/vlan.c \
 	lib/route/addr.c \
+	lib/route/bridge_vlan.c \
 	lib/route/class.c \
 	lib/route/classid.c \
 	lib/route/cls.c \
@@ -610,6 +613,7 @@ endif
 
 src_lib_libnl_cli_3_la_SOURCES = \
 	src/lib/addr.c \
+	src/lib/bridge_vlan.c \
 	src/lib/class.c \
 	src/lib/cls.c \
 	src/lib/ct.c \
@@ -677,6 +681,7 @@ cli_programs = \
 	src/nl-addr-add \
 	src/nl-addr-delete \
 	src/nl-addr-list \
+	src/nl-bridge \
 	src/nl-class-add \
 	src/nl-class-delete \
 	src/nl-class-list \
@@ -754,6 +759,8 @@ src_nl_addr_delete_CPPFLAGS =       $(src_cppflags)
 src_nl_addr_delete_LDADD =          $(src_ldadd)
 src_nl_addr_list_CPPFLAGS =         $(src_cppflags)
 src_nl_addr_list_LDADD =            $(src_ldadd)
+src_nl_bridge_CPPFLAGS =            $(src_cppflags)
+src_nl_bridge_LDADD =               $(src_ldadd)
 src_nl_class_add_CPPFLAGS =         $(src_cppflags)
 src_nl_class_add_LDADD =            $(src_ldadd)
 src_nl_class_delete_CPPFLAGS =      $(src_cppflags)
diff --git a/include/netlink-private/types.h b/include/netlink-private/types.h
index eec2e83..90e9298 100644
--- a/include/netlink-private/types.h
+++ b/include/netlink-private/types.h
@@ -1358,4 +1358,28 @@ struct rtnl_mdb_entry {
 
 	struct nl_list_head mdb_list;
 };
+
+struct rtnl_bvlan_entry {
+	uint32_t  ce_mask; /* HACK to support attr macros */
+
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_entry_list;
+};
+
+struct rtnl_bridge_vlan {
+	NLHDR_COMMON
+	uint32_t ifindex;
+	uint8_t family;
+
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_list;
+};
 #endif
diff --git a/include/netlink/cli/bridge_vlan.h b/include/netlink/cli/bridge_vlan.h
new file mode 100644
index 0000000..8d3adbd
--- /dev/null
+++ b/include/netlink/cli/bridge_vlan.h
@@ -0,0 +1,23 @@
+/*
+ * netlink/cli/link.h     CLI Link Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_BVLAN_H_
+#define __NETLINK_CLI_BVLAN_H_
+
+#include <netlink/route/link.h>
+#include <netlink/cli/utils.h>
+
+extern struct rtnl_bridge_vlan *nl_cli_bridge_vlan_alloc(void);
+extern struct nl_cache *nl_cli_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+						unsigned int flags);
+void nl_cli_bridge_vlan_parse_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex);
+
+#endif
diff --git a/include/netlink/route/bridge_vlan.h b/include/netlink/route/bridge_vlan.h
new file mode 100644
index 0000000..475e053
--- /dev/null
+++ b/include/netlink/route/bridge_vlan.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+
+#ifndef NETLINK_B_VLAN_H_
+#define NETLINK_B_VLAN_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void);
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache,
+						      int ifindex);
+	void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk,
+					 struct nl_cache **result);
+	int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+					       struct nl_cache **result,
+					       unsigned int flags);
+	int rtnl_bridge_vlan_change(struct nl_sock *sk,
+				    struct rtnl_bridge_vlan *orig,
+				    struct rtnl_bridge_vlan *changes,
+				    int flags);
+	int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig, struct rtnl_bridge_vlan
+						  *changes, int flags,
+						  struct nl_msg **result);
+	int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan,
+					 int ifindex);
+
+	struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void);
+	void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan,
+					struct rtnl_bvlan_entry *entry);
+	void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+					    void (*cb)(struct rtnl_bvlan_entry
+						       *, void *), void *arg);
+	struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct
+								 rtnl_bridge_vlan
+								 *obj);
+	int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan);
+	int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan,
+					       uint16_t vid);
+	uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry
+						 *bvlan);
+	int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan,
+					     uint8_t state);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/lib/route/bridge_vlan.c b/lib/route/bridge_vlan.c
new file mode 100644
index 0000000..1cf844d
--- /dev/null
+++ b/lib/route/bridge_vlan.c
@@ -0,0 +1,444 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * lib/route/bridge_vlan.c		Bridge VLAN database
+ */
+
+#include <netlink-private/netlink.h>
+#include <netlink/route/bridge_vlan.h>
+#include <netlink/netlink.h>
+#include <linux/if_bridge.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define BRIDGE_VLAN_ATTR_IFINDEX         0x000001
+#define BRIDGE_VLAN_ATTR_RANGE           0x000002
+#define BRIDGE_VLAN_ATTR_FAMILY          0x000004
+#define BRIDGE_VLAN_ATTR_VID             0x000008
+
+static struct nl_cache_ops rtnl_bridge_vlan_ops;
+static struct nl_object_ops bridge_vlan_obj_ops;
+/** @endcond */
+
+static void bridge_vlan_constructor(struct nl_object *obj)
+{
+	struct rtnl_bridge_vlan *_bridge_vlan = (struct rtnl_bridge_vlan *) obj;
+
+	nl_init_list_head(&_bridge_vlan->bridge_vlan_list);
+}
+
+static void bvlan_entry_free_data(struct rtnl_bvlan_entry *entry)
+{
+	free(entry);
+}
+
+static void bridge_vlan_free_data(struct nl_object *obj)
+{
+	struct rtnl_bridge_vlan *bvlan = (struct rtnl_bridge_vlan *) obj;
+	struct rtnl_bvlan_entry *bvlan_entry;
+
+//      nl_list_for_each_entry(bvlan_entry, &bvlan->bridge_vlan_list, bridge_vlan_entry_list)
+//          bvlan_entry_free_data(bvlan_entry);
+}
+
+static uint64_t bridge_vlan_compare(struct nl_object *_a, struct nl_object *_b,
+				    uint64_t attrs, int flags)
+{
+	struct rtnl_bridge_vlan *a = (struct rtnl_bridge_vlan *) _a;
+	struct rtnl_bridge_vlan *b = (struct rtnl_bridge_vlan *) _b;
+	uint64_t diff = 0;
+
+#if 0
+#define BRIDGE_VLAN_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, BRIDGE_VLAN_ATTR_##ATTR, a, b, EXPR)
+	diff |= BRIDGE_VLAN_DIFF(IFINDEX, a->ifindex != b->ifindex);
+#undef BRIDGE_VLAN_DIFF
+#endif
+	return 1;
+}
+
+static int bridge_vlan_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_bridge_vlan *dst = nl_object_priv(_dst);
+	struct rtnl_bridge_vlan *src = nl_object_priv(_src);
+
+	dst->ifindex = src->ifindex;
+	dst->family = src->family;
+	dst->state = src->state;
+	dst->vlan_id = src->vlan_id;
+	dst->range = src->range;
+
+	return 0;
+}
+
+static int bridge_vlan_update(struct nl_object *old_obj,
+			      struct nl_object *new_obj)
+{
+	struct rtnl_bridge_vlan *old = (struct rtnl_bridge_vlan *) old_obj;
+	struct rtnl_bridge_vlan *new = (struct rtnl_bridge_vlan *) new_obj;
+
+	return NLE_SUCCESS;
+}
+
+static void brvlan_entry_dump_line(struct rtnl_bvlan_entry *entry,
+				   struct nl_dump_params *p)
+{
+	nl_dump(p, " VLAN=%d", entry->vlan_id);
+	nl_dump(p, " State=%d\n", entry->state);
+
+	if (entry->range)
+		nl_dump(p, "RANGE=%d\n", entry->range);
+}
+
+static void br_vlan_dump_line(struct nl_object *_obj, struct nl_dump_params *p)
+{
+	struct rtnl_bridge_vlan *obj = (struct rtnl_bridge_vlan *) _obj;
+	struct rtnl_bvlan_entry *entry;
+
+	nl_dump(p, "Ifindex=%d:\n", obj->ifindex);
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list,
+			       bridge_vlan_entry_list) {
+		brvlan_entry_dump_line(entry, p);
+	}
+}
+
+static int bridge_vlan_request_update(struct nl_cache *cache,
+				      struct nl_sock *sk)
+{
+	int err;
+	struct br_vlan_msg gmsg = {
+		.family = AF_BRIDGE,
+	};
+
+	err = nl_send_simple(sk, RTM_GETVLAN, NLM_F_DUMP, &gmsg, sizeof(gmsg));
+	return err >= 0 ? 0 : err;
+}
+
+static struct nla_policy br_vlandb_policy[BRIDGE_VLANDB_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY] = {.type = NLA_NESTED},
+};
+
+static struct nla_policy br_vlandb_entry_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY_INFO] = {.type = NLA_BINARY,
+				      .minlen = sizeof(struct bridge_vlan_info),
+				      .maxlen =
+				      sizeof(struct bridge_vlan_info)},
+	[BRIDGE_VLANDB_ENTRY_RANGE] = {.type = NLA_U16},
+	[BRIDGE_VLANDB_ENTRY_STATE] = {.type = NLA_U8},
+	[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = {.type = NLA_NESTED},
+};
+
+static int bridge_vlan_msg_parser(struct nl_cache_ops *ops,
+				  struct sockaddr_nl *who, struct nlmsghdr *nlh,
+				  struct nl_parser_param *pp)
+{
+	int err = 0;
+	struct nlattr *tb[BRIDGE_VLANDB_MAX + 1],
+	    *ttb[BRIDGE_VLANDB_ENTRY_MAX + 1];
+	uint8_t state = 0;
+	uint16_t range = 0;
+	struct bridge_vlan_info *bvlan_info = NULL;
+	struct rtnl_bridge_vlan *bvlan = rtnl_bridge_vlan_alloc();
+	struct br_vlan_msg *bmsg = nlmsg_data(nlh);
+
+	err =
+	    nlmsg_parse(nlh, sizeof(struct br_vlan_msg), tb, BRIDGE_VLANDB_MAX,
+			br_vlandb_policy);
+	if (err < 0)
+		goto errout;
+
+	struct nlattr *pos;
+	int rem = nlh->nlmsg_len;
+
+	bvlan->ce_msgtype = nlh->nlmsg_type;
+
+	bvlan->ifindex = bmsg->ifindex;
+	bvlan->family = bmsg->family;
+	for (pos = nlmsg_data(nlh); nla_ok(pos, rem); pos = nla_next(pos, &rem)) {
+		if (nla_type(pos) != BRIDGE_VLANDB_ENTRY)
+			continue;
+
+		struct rtnl_bvlan_entry *_bvlan = rtnl_bvlan_entry_alloc();
+
+		nla_parse_nested(ttb, BRIDGE_VLANDB_ENTRY_MAX, pos,
+				 br_vlandb_entry_policy);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_INFO])
+			bvlan_info = nla_data(ttb[BRIDGE_VLANDB_ENTRY_INFO]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_STATE])
+			state = nla_get_u8(ttb[BRIDGE_VLANDB_ENTRY_STATE]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_RANGE])
+			range = nla_get_u16(ttb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+		_bvlan->state = state;
+		_bvlan->flags = bvlan_info->flags;
+		_bvlan->vlan_id = bvlan_info->vid;
+		_bvlan->range = range;
+
+		rtnl_bridge_vlan_add_entry(bvlan, _bvlan);
+	}
+
+	err = pp->pp_cb((struct nl_object *) bvlan, pp);
+errout:
+	rtnl_bridge_vlan_put(bvlan);
+	return err;
+}
+
+static struct nl_af_group br_vlan_groups[] = {
+	{AF_BRIDGE, RTNLGRP_BRVLAN},
+	{END_OF_GROUP_LIST},
+};
+
+static struct nl_object_ops bridge_vlan_obj_ops = {
+	.oo_name = "route/bridgevlan",
+	.oo_size = sizeof(struct rtnl_bridge_vlan),
+	.oo_dump = {
+		    [NL_DUMP_LINE] = br_vlan_dump_line,
+		    [NL_DUMP_DETAILS] = br_vlan_dump_line,
+		    [NL_DUMP_STATS] = br_vlan_dump_line,
+		    },
+	.oo_constructor = bridge_vlan_constructor,
+	.oo_compare = bridge_vlan_compare,
+	.oo_clone = bridge_vlan_clone,
+	.oo_update = bridge_vlan_update,
+	.oo_free_data = bridge_vlan_free_data,
+};
+
+static struct nl_cache_ops bridge_vlan_ops = {
+	.co_name = "route/bridgevlan",
+	.co_hdrsize = sizeof(struct br_vlan_msg),
+	.co_msgtypes = {
+			{RTM_NEWVLAN, NL_ACT_NEW, "new"},
+			{RTM_DELVLAN, NL_ACT_DEL, "del"},
+			{RTM_GETVLAN, NL_ACT_GET, "get"},
+			END_OF_MSGTYPES_LIST,
+			},
+	.co_protocol = NETLINK_ROUTE,
+	.co_groups = br_vlan_groups,
+	.co_request_update = bridge_vlan_request_update,
+	.co_msg_parser = bridge_vlan_msg_parser,
+	.co_obj_ops = &bridge_vlan_obj_ops,
+};
+
+/**
+ * @name Cache Management
+ * @{
+ */
+int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&bridge_vlan_ops, sk, result);
+}
+
+/**
+ * Build a bridge vlan cache including all Bridge VLAN entries currently configured in the kernel.
+ * @arg sock		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ * @arg flags		Flags to apply to cache before filling
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+				       struct nl_cache **result,
+				       unsigned int flags)
+{
+	struct nl_cache *cache = NULL;
+	int err;
+
+	cache = nl_cache_alloc(&bridge_vlan_ops);
+	if (!cache)
+		return -NLE_NOMEM;
+
+	nl_cache_set_flags(cache, flags);
+
+	if (sock && (err = nl_cache_refill(sock, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Add / Modify
+ * @{
+ */
+
+static int build_bridge_vlan_msg(int cmd, struct br_vlan_msg *hdr,
+				 struct rtnl_bridge_vlan *link, int flags,
+				 struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	*result = msg;
+	return 0;
+}
+
+int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig,
+					  struct rtnl_bridge_vlan *changes,
+					  int flags, struct nl_msg **result)
+{
+	struct br_vlan_msg bvlan = {
+		.family = orig->family,
+		.ifindex = orig->ifindex,
+	};
+	int err, rt;
+
+	build_bridge_vlan_msg(RTM_SETLINK, &bvlan, changes, flags, result);
+
+	return 0;
+}
+
+int rtnl_bridge_vlan_change(struct nl_sock *sk, struct rtnl_bridge_vlan *orig,
+			    struct rtnl_bridge_vlan *changes, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	err = rtnl_bridge_vlan_build_change_request(orig, changes, flags, &msg);
+
+	BUG_ON(msg->nm_nlh->nlmsg_seq != NL_AUTO_SEQ);
+retry:
+	err = nl_send_auto_complete(sk, msg);
+	if (err < 0)
+		goto errout;
+
+	err = wait_for_ack(sk);
+	if (err == -NLE_OPNOTSUPP && msg->nm_nlh->nlmsg_type == RTM_NEWLINK) {
+		msg->nm_nlh->nlmsg_type = RTM_SETLINK;
+		msg->nm_nlh->nlmsg_seq = NL_AUTO_SEQ;
+		goto retry;
+	}
+
+errout:
+	nlmsg_free(msg);
+	return err;
+}
+
+/** @} */
+
+/**
+ * @name Get/ Set
+ * @{
+ */
+void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan,
+				struct rtnl_bvlan_entry *entry)
+{
+	nl_list_add_tail(&entry->bridge_vlan_entry_list,
+			 &bvlan->bridge_vlan_list);
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache,
+					      int ifindex)
+{
+	struct rtnl_bridge_vlan *bvlan_entry;
+
+	if (cache->c_ops != &rtnl_bridge_vlan_ops)
+		return NULL;
+
+	nl_list_for_each_entry(bvlan_entry, &cache->c_items, ce_list) {
+		if (bvlan_entry->ifindex == ifindex) {
+			nl_object_get((struct nl_object *) bvlan_entry);
+			return bvlan_entry;
+		}
+	}
+
+	return NULL;
+
+}
+
+struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct rtnl_bridge_vlan
+							 *obj)
+{
+	return nl_list_first_entry(&obj->bridge_vlan_list,
+				   struct rtnl_bvlan_entry,
+				   bridge_vlan_entry_list);
+
+}
+
+void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+				    void (*cb)(struct rtnl_bvlan_entry *,
+					       void *), void *arg)
+{
+	struct rtnl_bvlan_entry *entry;
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list,
+			       bridge_vlan_entry_list) {
+		cb(entry, arg);
+	}
+}
+
+int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan)
+{
+	return bvlan->ifindex;
+}
+
+int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex)
+{
+	bvlan->ifindex = ifindex;
+	return 0;
+}
+
+int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->vlan_id;
+}
+
+int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan,
+				       uint16_t vid)
+{
+	bvlan->vlan_id = vid;
+	return 0;
+}
+
+uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->state;
+}
+
+int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan,
+				     uint8_t state)
+{
+	bvlan->state = state;
+	return 0;
+}
+
+/** @} */
+
+struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void)
+{
+	struct rtnl_bvlan_entry *entry;
+
+	entry = calloc(1, sizeof(struct rtnl_bvlan_entry));
+	if (!entry)
+		return NULL;
+	return entry;
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void)
+{
+	return (struct rtnl_bridge_vlan *)
+	    nl_object_alloc(&bridge_vlan_obj_ops);
+}
+
+void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan)
+{
+	nl_object_put((struct nl_object *) bvlan);
+
+}
+
+static void __init bridge_vlan_init(void)
+{
+	nl_cache_mngt_register(&bridge_vlan_ops);
+}
+
+static void __exit bridge_vlan_exit(void)
+{
+	nl_cache_mngt_register(&bridge_vlan_ops);
+}
+
+/** @} */
diff --git a/libnl-cli-3.sym b/libnl-cli-3.sym
index 71ff2eb..ed3bf34 100644
--- a/libnl-cli-3.sym
+++ b/libnl-cli-3.sym
@@ -114,4 +114,7 @@ global:
 	nl_cli_alloc_cache_flags;
 	nl_cli_link_alloc_cache_flags;
 	nl_cli_link_alloc_cache_family_flags;
+	nl_cli_bridge_vlan_alloc;
+	nl_cli_bridge_vlan_alloc_cache_flags;
+	nl_cli_bridge_vlan_parse_ifindex;
 } libnl_3;
diff --git a/libnl-route-3.sym b/libnl-route-3.sym
index 62b44ad..d7bca07 100644
--- a/libnl-route-3.sym
+++ b/libnl-route-3.sym
@@ -1172,4 +1172,15 @@ libnl_3_6 {
 	rtnl_mdb_entry_get_proto;
 	rtnl_mdb_entry_get_state;
 	rtnl_mdb_entry_get_vid;
+	rtnl_bridge_vlan_alloc;
+	rtnl_bridge_vlan_alloc_cache;
+	rtnl_bridge_vlan_alloc_cache_flags;
+	rtnl_bridge_vlan_get_ifindex;
+	rtnl_bridge_vlan_set_ifindex;
+	rtnl_bridge_vlan_entry_get_vlan_id;
+	rtnl_bridge_vlan_entry_set_vlan_id;
+	rtnl_bridge_vlan_entry_get_state;
+	rtnl_bridge_vlan_add_entry;
+	rtnl_bridge_vlan_foreach_entry;
+	rtnl_bridge_vlan_get_entry_head;
 } libnl_3_5;
diff --git a/src/lib/bridge_vlan.c b/src/lib/bridge_vlan.c
new file mode 100644
index 0000000..7f90a7f
--- /dev/null
+++ b/src/lib/bridge_vlan.c
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * src/lib/bridge_vlan.c     CLI Link Helpers
+ *
+ */
+
+/**
+ * @ingroup cli
+ * @defgroup cli_bridge_vlan Bridge Vlan
+ *
+ * @{
+ */
+
+#include <netlink/cli/utils.h>
+#include <netlink/cli/bridge_vlan.h>
+#include <linux/if_bridge.h>
+#include <netlink/route/bridge_vlan.h>
+
+struct rtnl_bridge_vlan *nl_cli_bridge_vlan_alloc(void)
+{
+	struct rtnl_bridge_vlan *bvlan;
+
+	bvlan = rtnl_bridge_vlan_alloc();
+	if (!bvlan)
+		nl_cli_fatal(ENOMEM, "Unable to allocate bridge-vlan object");
+
+	return bvlan;
+}
+
+struct nl_cache *nl_cli_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+						unsigned int flags)
+{
+	struct nl_cache *cache;
+	rtnl_bridge_vlan_alloc_cache_flags(sock, &cache, flags);
+
+	return cache;
+}
+
+void nl_cli_bridge_vlan_parse_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex)
+{
+	rtnl_bridge_vlan_set_ifindex(bvlan, ifindex);
+}
diff --git a/src/nl-bridge.c b/src/nl-bridge.c
new file mode 100644
index 0000000..32530fe
--- /dev/null
+++ b/src/nl-bridge.c
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * src/nl-bridge.c     Bridge utility
+ */
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/cli/utils.h>
+#include <netlink/cli/bridge_vlan.h>
+#include <netlink/cli/link.h>
+
+#include <netlink-private/cache-api.h>
+#include <linux/netlink.h>
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_link *bridge;
+	struct rtnl_bridge_vlan *bvlan = nl_cli_bridge_vlan_alloc();
+	struct nl_cache *bvlan_cache;
+	int err;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_DETAILS,
+		.dp_fd = stdout,
+	};
+
+	struct nl_cache_mngr *mngr;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	bvlan_cache = nl_cli_bridge_vlan_alloc_cache_flags(sock, NL_CACHE_AF_ITER);
+
+	nl_cache_dump(bvlan_cache, &dp);
+
+	printf("end\n");
+
+	return 0;
+}
diff --git a/src/nl-monitor.c b/src/nl-monitor.c
index 99aa0f4..a9e40c9 100644
--- a/src/nl-monitor.c
+++ b/src/nl-monitor.c
@@ -38,6 +38,7 @@ static const struct {
 	{ RTNLGRP_IPV6_NETCONF, "ipv6-netconf" },
 	{ RTNLGRP_MPLS_NETCONF, "mpls-netconf" },
 	{ RTNLGRP_MDB, "mdb" },
+	{ RTNLGRP_BRVLAN, "bridge-vlan" },
 	{ RTNLGRP_NONE, NULL }
 };
 
-- 
2.32.0

