From 0ac01f646ad3b021a199d5aad81b8056d3ebdcd4 Mon Sep 17 00:00:00 2001
From: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
Date: Fri, 29 Jan 2021 14:06:41 +0100
Subject: [PATCH] bridge-vlan: add per vlan stp state object and cache

Signed-off-by: Rubens Figueiredo <rubens.figueiredo@bisdn.de>
---
 Makefile.am                             |   7 +
 include/linux-private/linux/if_bridge.h | 444 ++++++++++++++++++++++++
 include/linux-private/linux/rtnetlink.h | 102 ++++--
 include/netlink-private/types.h         |  24 ++
 include/netlink/cli/bridge_vlan.h       |  23 ++
 include/netlink/route/bridge_vlan.h     |  51 +++
 lib/route/bridge_vlan.c                 | 444 ++++++++++++++++++++++++
 libnl-cli-3.sym                         |   3 +
 libnl-route-3.sym                       |  11 +
 src/nl-bridge.c                         |  38 ++
 src/nl-monitor.c                        |   1 +
 11 files changed, 1121 insertions(+), 27 deletions(-)
 create mode 100644 include/netlink/cli/bridge_vlan.h
 create mode 100644 include/netlink/route/bridge_vlan.h
 create mode 100644 lib/route/bridge_vlan.c
 create mode 100644 src/nl-bridge.c

diff --git a/Makefile.am b/Makefile.am
index 1d70059..77d796c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -102,6 +102,7 @@ libnlinclude_netlink_routedir = $(libnlincludedir)/netlink/route
 libnlinclude_netlink_route_HEADERS = \
 	include/netlink/route/action.h \
 	include/netlink/route/addr.h \
+	include/netlink/route/bridge_vlan.h \
 	include/netlink/route/class.h \
 	include/netlink/route/classifier.h \
 	include/netlink/route/link.h \
@@ -199,6 +200,7 @@ if ENABLE_CLI
 libnlinclude_netlink_clidir = $(libnlincludedir)/netlink/cli
 libnlinclude_netlink_cli_HEADERS = \
 	include/netlink/cli/addr.h \
+	include/netlink/cli/bridge_vlan.h \
 	include/netlink/cli/class.h \
 	include/netlink/cli/cls.h \
 	include/netlink/cli/ct.h \
@@ -376,6 +378,7 @@ lib_libnl_route_3_la_SOURCES = \
 	lib/route/act/skbedit.c \
 	lib/route/act/vlan.c \
 	lib/route/addr.c \
+	lib/route/bridge_vlan.c \
 	lib/route/class.c \
 	lib/route/classid.c \
 	lib/route/cls.c \
@@ -610,6 +613,7 @@ endif
 
 src_lib_libnl_cli_3_la_SOURCES = \
 	src/lib/addr.c \
+	src/lib/bridge_vlan.c \
 	src/lib/class.c \
 	src/lib/cls.c \
 	src/lib/ct.c \
@@ -677,6 +681,7 @@ cli_programs = \
 	src/nl-addr-add \
 	src/nl-addr-delete \
 	src/nl-addr-list \
+	src/nl-bridge \
 	src/nl-class-add \
 	src/nl-class-delete \
 	src/nl-class-list \
@@ -754,6 +759,8 @@ src_nl_addr_delete_CPPFLAGS =       $(src_cppflags)
 src_nl_addr_delete_LDADD =          $(src_ldadd)
 src_nl_addr_list_CPPFLAGS =         $(src_cppflags)
 src_nl_addr_list_LDADD =            $(src_ldadd)
+src_nl_bridge_CPPFLAGS =            $(src_cppflags)
+src_nl_bridge_LDADD =               $(src_ldadd)
 src_nl_class_add_CPPFLAGS =         $(src_cppflags)
 src_nl_class_add_LDADD =            $(src_ldadd)
 src_nl_class_delete_CPPFLAGS =      $(src_cppflags)
diff --git a/include/linux-private/linux/if_bridge.h b/include/linux-private/linux/if_bridge.h
index bdfecf9..fee6e45 100644
--- a/include/linux-private/linux/if_bridge.h
+++ b/include/linux-private/linux/if_bridge.h
@@ -120,6 +120,8 @@ enum {
 	IFLA_BRIDGE_MODE,
 	IFLA_BRIDGE_VLAN_INFO,
 	IFLA_BRIDGE_VLAN_TUNNEL_INFO,
+	IFLA_BRIDGE_MRP,
+	IFLA_BRIDGE_CFM,
 	__IFLA_BRIDGE_MAX,
 };
 #define IFLA_BRIDGE_MAX (__IFLA_BRIDGE_MAX - 1)
@@ -130,6 +132,7 @@ enum {
 #define BRIDGE_VLAN_INFO_RANGE_BEGIN	(1<<3) /* VLAN is start of vlan range */
 #define BRIDGE_VLAN_INFO_RANGE_END	(1<<4) /* VLAN is end of vlan range */
 #define BRIDGE_VLAN_INFO_BRENTRY	(1<<5) /* Global bridge VLAN entry */
+#define BRIDGE_VLAN_INFO_ONLY_OPTS	(1<<6) /* Skip create/delete/flags */
 
 struct bridge_vlan_info {
 	__u16 flags;
@@ -156,6 +159,385 @@ struct bridge_vlan_xstats {
 	__u32 pad2;
 };
 
+enum {
+	IFLA_BRIDGE_MRP_UNSPEC,
+	IFLA_BRIDGE_MRP_INSTANCE,
+	IFLA_BRIDGE_MRP_PORT_STATE,
+	IFLA_BRIDGE_MRP_PORT_ROLE,
+	IFLA_BRIDGE_MRP_RING_STATE,
+	IFLA_BRIDGE_MRP_RING_ROLE,
+	IFLA_BRIDGE_MRP_START_TEST,
+	IFLA_BRIDGE_MRP_INFO,
+	IFLA_BRIDGE_MRP_IN_ROLE,
+	IFLA_BRIDGE_MRP_IN_STATE,
+	IFLA_BRIDGE_MRP_START_IN_TEST,
+	__IFLA_BRIDGE_MRP_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_MAX (__IFLA_BRIDGE_MRP_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_INSTANCE_UNSPEC,
+	IFLA_BRIDGE_MRP_INSTANCE_RING_ID,
+	IFLA_BRIDGE_MRP_INSTANCE_P_IFINDEX,
+	IFLA_BRIDGE_MRP_INSTANCE_S_IFINDEX,
+	IFLA_BRIDGE_MRP_INSTANCE_PRIO,
+	__IFLA_BRIDGE_MRP_INSTANCE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_INSTANCE_MAX (__IFLA_BRIDGE_MRP_INSTANCE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_PORT_STATE_UNSPEC,
+	IFLA_BRIDGE_MRP_PORT_STATE_STATE,
+	__IFLA_BRIDGE_MRP_PORT_STATE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_PORT_STATE_MAX (__IFLA_BRIDGE_MRP_PORT_STATE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_PORT_ROLE_UNSPEC,
+	IFLA_BRIDGE_MRP_PORT_ROLE_ROLE,
+	__IFLA_BRIDGE_MRP_PORT_ROLE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_PORT_ROLE_MAX (__IFLA_BRIDGE_MRP_PORT_ROLE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_RING_STATE_UNSPEC,
+	IFLA_BRIDGE_MRP_RING_STATE_RING_ID,
+	IFLA_BRIDGE_MRP_RING_STATE_STATE,
+	__IFLA_BRIDGE_MRP_RING_STATE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_RING_STATE_MAX (__IFLA_BRIDGE_MRP_RING_STATE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_RING_ROLE_UNSPEC,
+	IFLA_BRIDGE_MRP_RING_ROLE_RING_ID,
+	IFLA_BRIDGE_MRP_RING_ROLE_ROLE,
+	__IFLA_BRIDGE_MRP_RING_ROLE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_RING_ROLE_MAX (__IFLA_BRIDGE_MRP_RING_ROLE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_START_TEST_UNSPEC,
+	IFLA_BRIDGE_MRP_START_TEST_RING_ID,
+	IFLA_BRIDGE_MRP_START_TEST_INTERVAL,
+	IFLA_BRIDGE_MRP_START_TEST_MAX_MISS,
+	IFLA_BRIDGE_MRP_START_TEST_PERIOD,
+	IFLA_BRIDGE_MRP_START_TEST_MONITOR,
+	__IFLA_BRIDGE_MRP_START_TEST_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_START_TEST_MAX (__IFLA_BRIDGE_MRP_START_TEST_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_INFO_UNSPEC,
+	IFLA_BRIDGE_MRP_INFO_RING_ID,
+	IFLA_BRIDGE_MRP_INFO_P_IFINDEX,
+	IFLA_BRIDGE_MRP_INFO_S_IFINDEX,
+	IFLA_BRIDGE_MRP_INFO_PRIO,
+	IFLA_BRIDGE_MRP_INFO_RING_STATE,
+	IFLA_BRIDGE_MRP_INFO_RING_ROLE,
+	IFLA_BRIDGE_MRP_INFO_TEST_INTERVAL,
+	IFLA_BRIDGE_MRP_INFO_TEST_MAX_MISS,
+	IFLA_BRIDGE_MRP_INFO_TEST_MONITOR,
+	IFLA_BRIDGE_MRP_INFO_I_IFINDEX,
+	IFLA_BRIDGE_MRP_INFO_IN_STATE,
+	IFLA_BRIDGE_MRP_INFO_IN_ROLE,
+	IFLA_BRIDGE_MRP_INFO_IN_TEST_INTERVAL,
+	IFLA_BRIDGE_MRP_INFO_IN_TEST_MAX_MISS,
+	__IFLA_BRIDGE_MRP_INFO_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_INFO_MAX (__IFLA_BRIDGE_MRP_INFO_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_IN_STATE_UNSPEC,
+	IFLA_BRIDGE_MRP_IN_STATE_IN_ID,
+	IFLA_BRIDGE_MRP_IN_STATE_STATE,
+	__IFLA_BRIDGE_MRP_IN_STATE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_IN_STATE_MAX (__IFLA_BRIDGE_MRP_IN_STATE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_IN_ROLE_UNSPEC,
+	IFLA_BRIDGE_MRP_IN_ROLE_RING_ID,
+	IFLA_BRIDGE_MRP_IN_ROLE_IN_ID,
+	IFLA_BRIDGE_MRP_IN_ROLE_ROLE,
+	IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX,
+	__IFLA_BRIDGE_MRP_IN_ROLE_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_IN_ROLE_MAX (__IFLA_BRIDGE_MRP_IN_ROLE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_MRP_START_IN_TEST_UNSPEC,
+	IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID,
+	IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL,
+	IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS,
+	IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD,
+	__IFLA_BRIDGE_MRP_START_IN_TEST_MAX,
+};
+
+#define IFLA_BRIDGE_MRP_START_IN_TEST_MAX (__IFLA_BRIDGE_MRP_START_IN_TEST_MAX - 1)
+
+struct br_mrp_instance {
+	__u32 ring_id;
+	__u32 p_ifindex;
+	__u32 s_ifindex;
+	__u16 prio;
+};
+
+struct br_mrp_ring_state {
+	__u32 ring_id;
+	__u32 ring_state;
+};
+
+struct br_mrp_ring_role {
+	__u32 ring_id;
+	__u32 ring_role;
+};
+
+struct br_mrp_start_test {
+	__u32 ring_id;
+	__u32 interval;
+	__u32 max_miss;
+	__u32 period;
+	__u32 monitor;
+};
+
+struct br_mrp_in_state {
+	__u32 in_state;
+	__u16 in_id;
+};
+
+struct br_mrp_in_role {
+	__u32 ring_id;
+	__u32 in_role;
+	__u32 i_ifindex;
+	__u16 in_id;
+};
+
+struct br_mrp_start_in_test {
+	__u32 interval;
+	__u32 max_miss;
+	__u32 period;
+	__u16 in_id;
+};
+
+enum {
+	IFLA_BRIDGE_CFM_UNSPEC,
+	IFLA_BRIDGE_CFM_MEP_CREATE,
+	IFLA_BRIDGE_CFM_MEP_DELETE,
+	IFLA_BRIDGE_CFM_MEP_CONFIG,
+	IFLA_BRIDGE_CFM_CC_CONFIG,
+	IFLA_BRIDGE_CFM_CC_PEER_MEP_ADD,
+	IFLA_BRIDGE_CFM_CC_PEER_MEP_REMOVE,
+	IFLA_BRIDGE_CFM_CC_RDI,
+	IFLA_BRIDGE_CFM_CC_CCM_TX,
+	IFLA_BRIDGE_CFM_MEP_CREATE_INFO,
+	IFLA_BRIDGE_CFM_MEP_CONFIG_INFO,
+	IFLA_BRIDGE_CFM_CC_CONFIG_INFO,
+	IFLA_BRIDGE_CFM_CC_RDI_INFO,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_INFO,
+	IFLA_BRIDGE_CFM_CC_PEER_MEP_INFO,
+	IFLA_BRIDGE_CFM_MEP_STATUS_INFO,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_INFO,
+	__IFLA_BRIDGE_CFM_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_MAX (__IFLA_BRIDGE_CFM_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_MEP_CREATE_UNSPEC,
+	IFLA_BRIDGE_CFM_MEP_CREATE_INSTANCE,
+	IFLA_BRIDGE_CFM_MEP_CREATE_DOMAIN,
+	IFLA_BRIDGE_CFM_MEP_CREATE_DIRECTION,
+	IFLA_BRIDGE_CFM_MEP_CREATE_IFINDEX,
+	__IFLA_BRIDGE_CFM_MEP_CREATE_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_MEP_CREATE_MAX (__IFLA_BRIDGE_CFM_MEP_CREATE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_MEP_DELETE_UNSPEC,
+	IFLA_BRIDGE_CFM_MEP_DELETE_INSTANCE,
+	__IFLA_BRIDGE_CFM_MEP_DELETE_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_MEP_DELETE_MAX (__IFLA_BRIDGE_CFM_MEP_DELETE_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_MEP_CONFIG_UNSPEC,
+	IFLA_BRIDGE_CFM_MEP_CONFIG_INSTANCE,
+	IFLA_BRIDGE_CFM_MEP_CONFIG_UNICAST_MAC,
+	IFLA_BRIDGE_CFM_MEP_CONFIG_MDLEVEL,
+	IFLA_BRIDGE_CFM_MEP_CONFIG_MEPID,
+	__IFLA_BRIDGE_CFM_MEP_CONFIG_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_MEP_CONFIG_MAX (__IFLA_BRIDGE_CFM_MEP_CONFIG_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_CC_CONFIG_UNSPEC,
+	IFLA_BRIDGE_CFM_CC_CONFIG_INSTANCE,
+	IFLA_BRIDGE_CFM_CC_CONFIG_ENABLE,
+	IFLA_BRIDGE_CFM_CC_CONFIG_EXP_INTERVAL,
+	IFLA_BRIDGE_CFM_CC_CONFIG_EXP_MAID,
+	__IFLA_BRIDGE_CFM_CC_CONFIG_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_CC_CONFIG_MAX (__IFLA_BRIDGE_CFM_CC_CONFIG_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_CC_PEER_MEP_UNSPEC,
+	IFLA_BRIDGE_CFM_CC_PEER_MEP_INSTANCE,
+	IFLA_BRIDGE_CFM_CC_PEER_MEPID,
+	__IFLA_BRIDGE_CFM_CC_PEER_MEP_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_CC_PEER_MEP_MAX (__IFLA_BRIDGE_CFM_CC_PEER_MEP_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_CC_RDI_UNSPEC,
+	IFLA_BRIDGE_CFM_CC_RDI_INSTANCE,
+	IFLA_BRIDGE_CFM_CC_RDI_RDI,
+	__IFLA_BRIDGE_CFM_CC_RDI_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_CC_RDI_MAX (__IFLA_BRIDGE_CFM_CC_RDI_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_CC_CCM_TX_UNSPEC,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_INSTANCE,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_DMAC,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_SEQ_NO_UPDATE,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_PERIOD,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_IF_TLV,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_IF_TLV_VALUE,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_PORT_TLV,
+	IFLA_BRIDGE_CFM_CC_CCM_TX_PORT_TLV_VALUE,
+	__IFLA_BRIDGE_CFM_CC_CCM_TX_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_CC_CCM_TX_MAX (__IFLA_BRIDGE_CFM_CC_CCM_TX_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_MEP_STATUS_UNSPEC,
+	IFLA_BRIDGE_CFM_MEP_STATUS_INSTANCE,
+	IFLA_BRIDGE_CFM_MEP_STATUS_OPCODE_UNEXP_SEEN,
+	IFLA_BRIDGE_CFM_MEP_STATUS_VERSION_UNEXP_SEEN,
+	IFLA_BRIDGE_CFM_MEP_STATUS_RX_LEVEL_LOW_SEEN,
+	__IFLA_BRIDGE_CFM_MEP_STATUS_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_MEP_STATUS_MAX (__IFLA_BRIDGE_CFM_MEP_STATUS_MAX - 1)
+
+enum {
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_UNSPEC,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_INSTANCE,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_PEER_MEPID,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_CCM_DEFECT,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_RDI,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_PORT_TLV_VALUE,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_IF_TLV_VALUE,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_SEEN,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_TLV_SEEN,
+	IFLA_BRIDGE_CFM_CC_PEER_STATUS_SEQ_UNEXP_SEEN,
+	__IFLA_BRIDGE_CFM_CC_PEER_STATUS_MAX,
+};
+
+#define IFLA_BRIDGE_CFM_CC_PEER_STATUS_MAX (__IFLA_BRIDGE_CFM_CC_PEER_STATUS_MAX - 1)
+
+struct bridge_stp_xstats {
+	__u64 transition_blk;
+	__u64 transition_fwd;
+	__u64 rx_bpdu;
+	__u64 tx_bpdu;
+	__u64 rx_tcn;
+	__u64 tx_tcn;
+};
+
+/* Bridge vlan RTM header */
+struct br_vlan_msg {
+	__u8 family;
+	__u8 reserved1;
+	__u16 reserved2;
+	__u32 ifindex;
+};
+
+enum {
+	BRIDGE_VLANDB_DUMP_UNSPEC,
+	BRIDGE_VLANDB_DUMP_FLAGS,
+	__BRIDGE_VLANDB_DUMP_MAX,
+};
+#define BRIDGE_VLANDB_DUMP_MAX (__BRIDGE_VLANDB_DUMP_MAX - 1)
+
+/* flags used in BRIDGE_VLANDB_DUMP_FLAGS attribute to affect dumps */
+#define BRIDGE_VLANDB_DUMPF_STATS	(1 << 0) /* Include stats in the dump */
+
+/* Bridge vlan RTM attributes
+ * [BRIDGE_VLANDB_ENTRY] = {
+ *     [BRIDGE_VLANDB_ENTRY_INFO]
+ *     ...
+ * }
+ */
+enum {
+	BRIDGE_VLANDB_UNSPEC,
+	BRIDGE_VLANDB_ENTRY,
+	__BRIDGE_VLANDB_MAX,
+};
+#define BRIDGE_VLANDB_MAX (__BRIDGE_VLANDB_MAX - 1)
+
+enum {
+	BRIDGE_VLANDB_ENTRY_UNSPEC,
+	BRIDGE_VLANDB_ENTRY_INFO,
+	BRIDGE_VLANDB_ENTRY_RANGE,
+	BRIDGE_VLANDB_ENTRY_STATE,
+	BRIDGE_VLANDB_ENTRY_TUNNEL_INFO,
+	BRIDGE_VLANDB_ENTRY_STATS,
+	__BRIDGE_VLANDB_ENTRY_MAX,
+};
+#define BRIDGE_VLANDB_ENTRY_MAX (__BRIDGE_VLANDB_ENTRY_MAX - 1)
+
+/* [BRIDGE_VLANDB_ENTRY] = {
+ *     [BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = {
+ *         [BRIDGE_VLANDB_TINFO_ID]
+ *         ...
+ *     }
+ * }
+ */
+enum {
+	BRIDGE_VLANDB_TINFO_UNSPEC,
+	BRIDGE_VLANDB_TINFO_ID,
+	BRIDGE_VLANDB_TINFO_CMD,
+	__BRIDGE_VLANDB_TINFO_MAX,
+};
+#define BRIDGE_VLANDB_TINFO_MAX (__BRIDGE_VLANDB_TINFO_MAX - 1)
+
+/* [BRIDGE_VLANDB_ENTRY] = {
+ *     [BRIDGE_VLANDB_ENTRY_STATS] = {
+ *         [BRIDGE_VLANDB_STATS_RX_BYTES]
+ *         ...
+ *     }
+ *     ...
+ * }
+ */
+enum {
+	BRIDGE_VLANDB_STATS_UNSPEC,
+	BRIDGE_VLANDB_STATS_RX_BYTES,
+	BRIDGE_VLANDB_STATS_RX_PACKETS,
+	BRIDGE_VLANDB_STATS_TX_BYTES,
+	BRIDGE_VLANDB_STATS_TX_PACKETS,
+	BRIDGE_VLANDB_STATS_PAD,
+	__BRIDGE_VLANDB_STATS_MAX,
+};
+#define BRIDGE_VLANDB_STATS_MAX (__BRIDGE_VLANDB_STATS_MAX - 1)
+
 /* Bridge multicast database attributes
  * [MDBA_MDB] = {
  *     [MDBA_MDB_ENTRY] = {
@@ -198,10 +580,33 @@ enum {
 enum {
 	MDBA_MDB_EATTR_UNSPEC,
 	MDBA_MDB_EATTR_TIMER,
+	MDBA_MDB_EATTR_SRC_LIST,
+	MDBA_MDB_EATTR_GROUP_MODE,
+	MDBA_MDB_EATTR_SOURCE,
+	MDBA_MDB_EATTR_RTPROT,
 	__MDBA_MDB_EATTR_MAX
 };
 #define MDBA_MDB_EATTR_MAX (__MDBA_MDB_EATTR_MAX - 1)
 
+/* per mdb entry source */
+enum {
+	MDBA_MDB_SRCLIST_UNSPEC,
+	MDBA_MDB_SRCLIST_ENTRY,
+	__MDBA_MDB_SRCLIST_MAX
+};
+#define MDBA_MDB_SRCLIST_MAX (__MDBA_MDB_SRCLIST_MAX - 1)
+
+/* per mdb entry per source attributes
+ * these are embedded in MDBA_MDB_SRCLIST_ENTRY
+ */
+enum {
+	MDBA_MDB_SRCATTR_UNSPEC,
+	MDBA_MDB_SRCATTR_ADDRESS,
+	MDBA_MDB_SRCATTR_TIMER,
+	__MDBA_MDB_SRCATTR_MAX
+};
+#define MDBA_MDB_SRCATTR_MAX (__MDBA_MDB_SRCATTR_MAX - 1)
+
 /* multicast router types */
 enum {
 	MDB_RTR_TYPE_DISABLED,
@@ -237,12 +642,16 @@ struct br_mdb_entry {
 #define MDB_PERMANENT 1
 	__u8 state;
 #define MDB_FLAGS_OFFLOAD	(1 << 0)
+#define MDB_FLAGS_FAST_LEAVE	(1 << 1)
+#define MDB_FLAGS_STAR_EXCL	(1 << 2)
+#define MDB_FLAGS_BLOCKED	(1 << 3)
 	__u8 flags;
 	__u16 vid;
 	struct {
 		union {
 			__be32	ip4;
 			struct in6_addr ip6;
+			unsigned char mac_addr[ETH_ALEN];
 		} u;
 		__be16		proto;
 	} addr;
@@ -251,16 +660,30 @@ struct br_mdb_entry {
 enum {
 	MDBA_SET_ENTRY_UNSPEC,
 	MDBA_SET_ENTRY,
+	MDBA_SET_ENTRY_ATTRS,
 	__MDBA_SET_ENTRY_MAX,
 };
 #define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)
 
+/* [MDBA_SET_ENTRY_ATTRS] = {
+ *    [MDBE_ATTR_xxx]
+ *    ...
+ * }
+ */
+enum {
+	MDBE_ATTR_UNSPEC,
+	MDBE_ATTR_SOURCE,
+	__MDBE_ATTR_MAX,
+};
+#define MDBE_ATTR_MAX (__MDBE_ATTR_MAX - 1)
+
 /* Embedded inside LINK_XSTATS_TYPE_BRIDGE */
 enum {
 	BRIDGE_XSTATS_UNSPEC,
 	BRIDGE_XSTATS_VLAN,
 	BRIDGE_XSTATS_MCAST,
 	BRIDGE_XSTATS_PAD,
+	BRIDGE_XSTATS_STP,
 	__BRIDGE_XSTATS_MAX
 };
 #define BRIDGE_XSTATS_MAX (__BRIDGE_XSTATS_MAX - 1)
@@ -292,4 +715,25 @@ struct br_mcast_stats {
 	__u64 mcast_bytes[BR_MCAST_DIR_SIZE];
 	__u64 mcast_packets[BR_MCAST_DIR_SIZE];
 };
+
+/* bridge boolean options
+ * BR_BOOLOPT_NO_LL_LEARN - disable learning from link-local packets
+ *
+ * IMPORTANT: if adding a new option do not forget to handle
+ *            it in br_boolopt_toggle/get and bridge sysfs
+ */
+enum br_boolopt_id {
+	BR_BOOLOPT_NO_LL_LEARN,
+	BR_BOOLOPT_MAX
+};
+
+/* struct br_boolopt_multi - change multiple bridge boolean options
+ *
+ * @optval: new option values (bit per option)
+ * @optmask: options to change (bit per option)
+ */
+struct br_boolopt_multi {
+	__u32 optval;
+	__u32 optmask;
+};
 #endif /* _LINUX_IF_BRIDGE_H */
diff --git a/include/linux-private/linux/rtnetlink.h b/include/linux-private/linux/rtnetlink.h
index 8c1d600..98ee2db 100644
--- a/include/linux-private/linux/rtnetlink.h
+++ b/include/linux-private/linux/rtnetlink.h
@@ -157,6 +157,27 @@ enum {
 	RTM_GETCHAIN,
 #define RTM_GETCHAIN RTM_GETCHAIN
 
+	RTM_NEWNEXTHOP = 104,
+#define RTM_NEWNEXTHOP	RTM_NEWNEXTHOP
+	RTM_DELNEXTHOP,
+#define RTM_DELNEXTHOP	RTM_DELNEXTHOP
+	RTM_GETNEXTHOP,
+#define RTM_GETNEXTHOP	RTM_GETNEXTHOP
+
+	RTM_NEWLINKPROP = 108,
+#define RTM_NEWLINKPROP	RTM_NEWLINKPROP
+	RTM_DELLINKPROP,
+#define RTM_DELLINKPROP	RTM_DELLINKPROP
+	RTM_GETLINKPROP,
+#define RTM_GETLINKPROP	RTM_GETLINKPROP
+
+	RTM_NEWVLAN = 112,
+#define RTM_NEWNVLAN	RTM_NEWVLAN
+	RTM_DELVLAN,
+#define RTM_DELVLAN	RTM_DELVLAN
+	RTM_GETVLAN,
+#define RTM_GETVLAN	RTM_GETVLAN
+
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
@@ -236,12 +257,12 @@ enum {
 
 /* rtm_protocol */
 
-#define RTPROT_UNSPEC	0
-#define RTPROT_REDIRECT	1	/* Route installed by ICMP redirects;
-				   not used by current IPv4 */
-#define RTPROT_KERNEL	2	/* Route installed by kernel		*/
-#define RTPROT_BOOT	3	/* Route installed during boot		*/
-#define RTPROT_STATIC	4	/* Route installed by administrator	*/
+#define RTPROT_UNSPEC		0
+#define RTPROT_REDIRECT		1	/* Route installed by ICMP redirects;
+					   not used by current IPv4 */
+#define RTPROT_KERNEL		2	/* Route installed by kernel		*/
+#define RTPROT_BOOT		3	/* Route installed during boot		*/
+#define RTPROT_STATIC		4	/* Route installed by administrator	*/
 
 /* Values of protocol >= RTPROT_STATIC are not interpreted by kernel;
    they are just passed from user and back as is.
@@ -250,22 +271,23 @@ enum {
    avoid conflicts.
  */
 
-#define RTPROT_GATED	8	/* Apparently, GateD */
-#define RTPROT_RA	9	/* RDISC/ND router advertisements */
-#define RTPROT_MRT	10	/* Merit MRT */
-#define RTPROT_ZEBRA	11	/* Zebra */
-#define RTPROT_BIRD	12	/* BIRD */
-#define RTPROT_DNROUTED	13	/* DECnet routing daemon */
-#define RTPROT_XORP	14	/* XORP */
-#define RTPROT_NTK	15	/* Netsukuku */
-#define RTPROT_DHCP	16      /* DHCP client */
-#define RTPROT_MROUTED	17      /* Multicast daemon */
-#define RTPROT_BABEL	42      /* Babel daemon */
-#define RTPROT_BGP	186     /* BGP Routes */
-#define RTPROT_ISIS	187     /* ISIS Routes */
-#define RTPROT_OSPF	188     /* OSPF Routes */
-#define RTPROT_RIP	189     /* RIP Routes */
-#define RTPROT_EIGRP	192     /* EIGRP Routes */
+#define RTPROT_GATED		8	/* Apparently, GateD */
+#define RTPROT_RA		9	/* RDISC/ND router advertisements */
+#define RTPROT_MRT		10	/* Merit MRT */
+#define RTPROT_ZEBRA		11	/* Zebra */
+#define RTPROT_BIRD		12	/* BIRD */
+#define RTPROT_DNROUTED		13	/* DECnet routing daemon */
+#define RTPROT_XORP		14	/* XORP */
+#define RTPROT_NTK		15	/* Netsukuku */
+#define RTPROT_DHCP		16	/* DHCP client */
+#define RTPROT_MROUTED		17	/* Multicast daemon */
+#define RTPROT_KEEPALIVED	18	/* Keepalived daemon */
+#define RTPROT_BABEL		42	/* Babel daemon */
+#define RTPROT_BGP		186	/* BGP Routes */
+#define RTPROT_ISIS		187	/* ISIS Routes */
+#define RTPROT_OSPF		188	/* OSPF Routes */
+#define RTPROT_RIP		189	/* RIP Routes */
+#define RTPROT_EIGRP		192	/* EIGRP Routes */
 
 /* rtm_scope
 
@@ -295,6 +317,8 @@ enum rt_scope_t {
 #define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
 #define RTM_F_LOOKUP_TABLE	0x1000	/* set rtm_table to FIB lookup result */
 #define RTM_F_FIB_MATCH	        0x2000	/* return full fib lookup match */
+#define RTM_F_OFFLOAD		0x4000	/* route is offloaded */
+#define RTM_F_TRAP		0x8000	/* route is trapping packets */
 
 /* Reserved table identifiers */
 
@@ -342,6 +366,7 @@ enum rtattr_type_t {
 	RTA_IP_PROTO,
 	RTA_SPORT,
 	RTA_DPORT,
+	RTA_NH_ID,
 	__RTA_MAX
 };
 
@@ -371,11 +396,13 @@ struct rtnexthop {
 #define RTNH_F_DEAD		1	/* Nexthop is dead (used by multipath)	*/
 #define RTNH_F_PERVASIVE	2	/* Do recursive gateway lookup	*/
 #define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
-#define RTNH_F_OFFLOAD		8	/* offloaded route */
+#define RTNH_F_OFFLOAD		8	/* Nexthop is offloaded */
 #define RTNH_F_LINKDOWN		16	/* carrier-down on nexthop */
 #define RTNH_F_UNRESOLVED	32	/* The entry is unresolved (ipmr) */
+#define RTNH_F_TRAP		64	/* Nexthop is trapping packets */
 
-#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | RTNH_F_OFFLOAD)
+#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | \
+				 RTNH_F_OFFLOAD | RTNH_F_TRAP)
 
 /* Macros to handle hexthops */
 
@@ -585,11 +612,17 @@ enum {
 	TCA_HW_OFFLOAD,
 	TCA_INGRESS_BLOCK,
 	TCA_EGRESS_BLOCK,
+	TCA_DUMP_FLAGS,
 	__TCA_MAX
 };
 
 #define TCA_MAX (__TCA_MAX - 1)
 
+#define TCA_DUMP_FLAGS_TERSE (1 << 0) /* Means that in dump user gets only basic
+				       * data necessary to identify the objects
+				       * (handle, cookie, etc.) and stats.
+				       */
+
 #define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
 #define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
 
@@ -617,6 +650,7 @@ enum {
 
 #define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
 
+#ifndef __KERNEL__
 /* RTnetlink multicast groups - backwards compatibility for userspace */
 #define RTMGRP_LINK		1
 #define RTMGRP_NOTIFY		2
@@ -637,6 +671,7 @@ enum {
 #define RTMGRP_DECnet_ROUTE     0x4000
 
 #define RTMGRP_IPV6_PREFIX	0x20000
+#endif
 
 /* RTnetlink multicast groups */
 enum rtnetlink_groups {
@@ -702,6 +737,10 @@ enum rtnetlink_groups {
 #define RTNLGRP_IPV4_MROUTE_R	RTNLGRP_IPV4_MROUTE_R
 	RTNLGRP_IPV6_MROUTE_R,
 #define RTNLGRP_IPV6_MROUTE_R	RTNLGRP_IPV6_MROUTE_R
+	RTNLGRP_NEXTHOP,
+#define RTNLGRP_NEXTHOP		RTNLGRP_NEXTHOP
+	RTNLGRP_BRVLAN,
+#define RTNLGRP_BRVLAN		RTNLGRP_BRVLAN
 	__RTNLGRP_MAX
 };
 #define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
@@ -729,18 +768,27 @@ enum {
 #define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
 /* tcamsg flags stored in attribute TCA_ROOT_FLAGS
  *
- * TCA_FLAG_LARGE_DUMP_ON user->kernel to request for larger than TCA_ACT_MAX_PRIO
- * actions in a dump. All dump responses will contain the number of actions
- * being dumped stored in for user app's consumption in TCA_ROOT_COUNT
+ * TCA_ACT_FLAG_LARGE_DUMP_ON user->kernel to request for larger than
+ * TCA_ACT_MAX_PRIO actions in a dump. All dump responses will contain the
+ * number of actions being dumped stored in for user app's consumption in
+ * TCA_ROOT_COUNT
+ *
+ * TCA_ACT_FLAG_TERSE_DUMP user->kernel to request terse (brief) dump that only
+ * includes essential action info (kind, index, etc.)
  *
  */
 #define TCA_FLAG_LARGE_DUMP_ON		(1 << 0)
+#define TCA_ACT_FLAG_LARGE_DUMP_ON	TCA_FLAG_LARGE_DUMP_ON
+#define TCA_ACT_FLAG_TERSE_DUMP		(1 << 1)
 
 /* New extended info filters for IFLA_EXT_MASK */
 #define RTEXT_FILTER_VF		(1 << 0)
 #define RTEXT_FILTER_BRVLAN	(1 << 1)
 #define RTEXT_FILTER_BRVLAN_COMPRESSED	(1 << 2)
 #define	RTEXT_FILTER_SKIP_STATS	(1 << 3)
+#define RTEXT_FILTER_MRP	(1 << 4)
+#define RTEXT_FILTER_CFM_CONFIG	(1 << 5)
+#define RTEXT_FILTER_CFM_STATUS	(1 << 6)
 
 /* End of information exported to user level */
 
diff --git a/include/netlink-private/types.h b/include/netlink-private/types.h
index eec2e83..90e9298 100644
--- a/include/netlink-private/types.h
+++ b/include/netlink-private/types.h
@@ -1358,4 +1358,28 @@ struct rtnl_mdb_entry {
 
 	struct nl_list_head mdb_list;
 };
+
+struct rtnl_bvlan_entry {
+	uint32_t  ce_mask; /* HACK to support attr macros */
+
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_entry_list;
+};
+
+struct rtnl_bridge_vlan {
+	NLHDR_COMMON
+	uint32_t ifindex;
+	uint8_t family;
+
+	uint16_t vlan_id;
+	uint16_t flags;
+	uint16_t range;
+	uint8_t state;
+
+	struct nl_list_head bridge_vlan_list;
+};
 #endif
diff --git a/include/netlink/cli/bridge_vlan.h b/include/netlink/cli/bridge_vlan.h
new file mode 100644
index 0000000..8d3adbd
--- /dev/null
+++ b/include/netlink/cli/bridge_vlan.h
@@ -0,0 +1,23 @@
+/*
+ * netlink/cli/link.h     CLI Link Helpers
+ *
+ *	This library is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU Lesser General Public
+ *	License as published by the Free Software Foundation version 2.1
+ *	of the License.
+ *
+ * Copyright (c) 2008-2010 Thomas Graf <tgraf@suug.ch>
+ */
+
+#ifndef __NETLINK_CLI_BVLAN_H_
+#define __NETLINK_CLI_BVLAN_H_
+
+#include <netlink/route/link.h>
+#include <netlink/cli/utils.h>
+
+extern struct rtnl_bridge_vlan *nl_cli_bridge_vlan_alloc(void);
+extern struct nl_cache *nl_cli_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+						unsigned int flags);
+void nl_cli_bridge_vlan_parse_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex);
+
+#endif
diff --git a/include/netlink/route/bridge_vlan.h b/include/netlink/route/bridge_vlan.h
new file mode 100644
index 0000000..475e053
--- /dev/null
+++ b/include/netlink/route/bridge_vlan.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+
+#ifndef NETLINK_B_VLAN_H_
+#define NETLINK_B_VLAN_H_
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void);
+	struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache,
+						      int ifindex);
+	void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk,
+					 struct nl_cache **result);
+	int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+					       struct nl_cache **result,
+					       unsigned int flags);
+	int rtnl_bridge_vlan_change(struct nl_sock *sk,
+				    struct rtnl_bridge_vlan *orig,
+				    struct rtnl_bridge_vlan *changes,
+				    int flags);
+	int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig, struct rtnl_bridge_vlan
+						  *changes, int flags,
+						  struct nl_msg **result);
+	int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan);
+	int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan,
+					 int ifindex);
+
+	struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void);
+	void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan,
+					struct rtnl_bvlan_entry *entry);
+	void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+					    void (*cb)(struct rtnl_bvlan_entry
+						       *, void *), void *arg);
+	struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct
+								 rtnl_bridge_vlan
+								 *obj);
+	int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan);
+	int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan,
+					       uint16_t vid);
+	uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry
+						 *bvlan);
+	int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan,
+					     uint8_t state);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/lib/route/bridge_vlan.c b/lib/route/bridge_vlan.c
new file mode 100644
index 0000000..1cf844d
--- /dev/null
+++ b/lib/route/bridge_vlan.c
@@ -0,0 +1,444 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * lib/route/bridge_vlan.c		Bridge VLAN database
+ */
+
+#include <netlink-private/netlink.h>
+#include <netlink/route/bridge_vlan.h>
+#include <netlink/netlink.h>
+#include <linux/if_bridge.h>
+#include <netlink/utils.h>
+
+/** @cond SKIP */
+#define BRIDGE_VLAN_ATTR_IFINDEX         0x000001
+#define BRIDGE_VLAN_ATTR_RANGE           0x000002
+#define BRIDGE_VLAN_ATTR_FAMILY          0x000004
+#define BRIDGE_VLAN_ATTR_VID             0x000008
+
+static struct nl_cache_ops rtnl_bridge_vlan_ops;
+static struct nl_object_ops bridge_vlan_obj_ops;
+/** @endcond */
+
+static void bridge_vlan_constructor(struct nl_object *obj)
+{
+	struct rtnl_bridge_vlan *_bridge_vlan = (struct rtnl_bridge_vlan *) obj;
+
+	nl_init_list_head(&_bridge_vlan->bridge_vlan_list);
+}
+
+static void bvlan_entry_free_data(struct rtnl_bvlan_entry *entry)
+{
+	free(entry);
+}
+
+static void bridge_vlan_free_data(struct nl_object *obj)
+{
+	struct rtnl_bridge_vlan *bvlan = (struct rtnl_bridge_vlan *) obj;
+	struct rtnl_bvlan_entry *bvlan_entry;
+
+//      nl_list_for_each_entry(bvlan_entry, &bvlan->bridge_vlan_list, bridge_vlan_entry_list)
+//          bvlan_entry_free_data(bvlan_entry);
+}
+
+static uint64_t bridge_vlan_compare(struct nl_object *_a, struct nl_object *_b,
+				    uint64_t attrs, int flags)
+{
+	struct rtnl_bridge_vlan *a = (struct rtnl_bridge_vlan *) _a;
+	struct rtnl_bridge_vlan *b = (struct rtnl_bridge_vlan *) _b;
+	uint64_t diff = 0;
+
+#if 0
+#define BRIDGE_VLAN_DIFF(ATTR, EXPR) ATTR_DIFF(attrs, BRIDGE_VLAN_ATTR_##ATTR, a, b, EXPR)
+	diff |= BRIDGE_VLAN_DIFF(IFINDEX, a->ifindex != b->ifindex);
+#undef BRIDGE_VLAN_DIFF
+#endif
+	return 1;
+}
+
+static int bridge_vlan_clone(struct nl_object *_dst, struct nl_object *_src)
+{
+	struct rtnl_bridge_vlan *dst = nl_object_priv(_dst);
+	struct rtnl_bridge_vlan *src = nl_object_priv(_src);
+
+	dst->ifindex = src->ifindex;
+	dst->family = src->family;
+	dst->state = src->state;
+	dst->vlan_id = src->vlan_id;
+	dst->range = src->range;
+
+	return 0;
+}
+
+static int bridge_vlan_update(struct nl_object *old_obj,
+			      struct nl_object *new_obj)
+{
+	struct rtnl_bridge_vlan *old = (struct rtnl_bridge_vlan *) old_obj;
+	struct rtnl_bridge_vlan *new = (struct rtnl_bridge_vlan *) new_obj;
+
+	return NLE_SUCCESS;
+}
+
+static void brvlan_entry_dump_line(struct rtnl_bvlan_entry *entry,
+				   struct nl_dump_params *p)
+{
+	nl_dump(p, " VLAN=%d", entry->vlan_id);
+	nl_dump(p, " State=%d\n", entry->state);
+
+	if (entry->range)
+		nl_dump(p, "RANGE=%d\n", entry->range);
+}
+
+static void br_vlan_dump_line(struct nl_object *_obj, struct nl_dump_params *p)
+{
+	struct rtnl_bridge_vlan *obj = (struct rtnl_bridge_vlan *) _obj;
+	struct rtnl_bvlan_entry *entry;
+
+	nl_dump(p, "Ifindex=%d:\n", obj->ifindex);
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list,
+			       bridge_vlan_entry_list) {
+		brvlan_entry_dump_line(entry, p);
+	}
+}
+
+static int bridge_vlan_request_update(struct nl_cache *cache,
+				      struct nl_sock *sk)
+{
+	int err;
+	struct br_vlan_msg gmsg = {
+		.family = AF_BRIDGE,
+	};
+
+	err = nl_send_simple(sk, RTM_GETVLAN, NLM_F_DUMP, &gmsg, sizeof(gmsg));
+	return err >= 0 ? 0 : err;
+}
+
+static struct nla_policy br_vlandb_policy[BRIDGE_VLANDB_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY] = {.type = NLA_NESTED},
+};
+
+static struct nla_policy br_vlandb_entry_policy[BRIDGE_VLANDB_ENTRY_MAX + 1] = {
+	[BRIDGE_VLANDB_ENTRY_INFO] = {.type = NLA_BINARY,
+				      .minlen = sizeof(struct bridge_vlan_info),
+				      .maxlen =
+				      sizeof(struct bridge_vlan_info)},
+	[BRIDGE_VLANDB_ENTRY_RANGE] = {.type = NLA_U16},
+	[BRIDGE_VLANDB_ENTRY_STATE] = {.type = NLA_U8},
+	[BRIDGE_VLANDB_ENTRY_TUNNEL_INFO] = {.type = NLA_NESTED},
+};
+
+static int bridge_vlan_msg_parser(struct nl_cache_ops *ops,
+				  struct sockaddr_nl *who, struct nlmsghdr *nlh,
+				  struct nl_parser_param *pp)
+{
+	int err = 0;
+	struct nlattr *tb[BRIDGE_VLANDB_MAX + 1],
+	    *ttb[BRIDGE_VLANDB_ENTRY_MAX + 1];
+	uint8_t state = 0;
+	uint16_t range = 0;
+	struct bridge_vlan_info *bvlan_info = NULL;
+	struct rtnl_bridge_vlan *bvlan = rtnl_bridge_vlan_alloc();
+	struct br_vlan_msg *bmsg = nlmsg_data(nlh);
+
+	err =
+	    nlmsg_parse(nlh, sizeof(struct br_vlan_msg), tb, BRIDGE_VLANDB_MAX,
+			br_vlandb_policy);
+	if (err < 0)
+		goto errout;
+
+	struct nlattr *pos;
+	int rem = nlh->nlmsg_len;
+
+	bvlan->ce_msgtype = nlh->nlmsg_type;
+
+	bvlan->ifindex = bmsg->ifindex;
+	bvlan->family = bmsg->family;
+	for (pos = nlmsg_data(nlh); nla_ok(pos, rem); pos = nla_next(pos, &rem)) {
+		if (nla_type(pos) != BRIDGE_VLANDB_ENTRY)
+			continue;
+
+		struct rtnl_bvlan_entry *_bvlan = rtnl_bvlan_entry_alloc();
+
+		nla_parse_nested(ttb, BRIDGE_VLANDB_ENTRY_MAX, pos,
+				 br_vlandb_entry_policy);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_INFO])
+			bvlan_info = nla_data(ttb[BRIDGE_VLANDB_ENTRY_INFO]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_STATE])
+			state = nla_get_u8(ttb[BRIDGE_VLANDB_ENTRY_STATE]);
+
+		if (ttb[BRIDGE_VLANDB_ENTRY_RANGE])
+			range = nla_get_u16(ttb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+		_bvlan->state = state;
+		_bvlan->flags = bvlan_info->flags;
+		_bvlan->vlan_id = bvlan_info->vid;
+		_bvlan->range = range;
+
+		rtnl_bridge_vlan_add_entry(bvlan, _bvlan);
+	}
+
+	err = pp->pp_cb((struct nl_object *) bvlan, pp);
+errout:
+	rtnl_bridge_vlan_put(bvlan);
+	return err;
+}
+
+static struct nl_af_group br_vlan_groups[] = {
+	{AF_BRIDGE, RTNLGRP_BRVLAN},
+	{END_OF_GROUP_LIST},
+};
+
+static struct nl_object_ops bridge_vlan_obj_ops = {
+	.oo_name = "route/bridgevlan",
+	.oo_size = sizeof(struct rtnl_bridge_vlan),
+	.oo_dump = {
+		    [NL_DUMP_LINE] = br_vlan_dump_line,
+		    [NL_DUMP_DETAILS] = br_vlan_dump_line,
+		    [NL_DUMP_STATS] = br_vlan_dump_line,
+		    },
+	.oo_constructor = bridge_vlan_constructor,
+	.oo_compare = bridge_vlan_compare,
+	.oo_clone = bridge_vlan_clone,
+	.oo_update = bridge_vlan_update,
+	.oo_free_data = bridge_vlan_free_data,
+};
+
+static struct nl_cache_ops bridge_vlan_ops = {
+	.co_name = "route/bridgevlan",
+	.co_hdrsize = sizeof(struct br_vlan_msg),
+	.co_msgtypes = {
+			{RTM_NEWVLAN, NL_ACT_NEW, "new"},
+			{RTM_DELVLAN, NL_ACT_DEL, "del"},
+			{RTM_GETVLAN, NL_ACT_GET, "get"},
+			END_OF_MSGTYPES_LIST,
+			},
+	.co_protocol = NETLINK_ROUTE,
+	.co_groups = br_vlan_groups,
+	.co_request_update = bridge_vlan_request_update,
+	.co_msg_parser = bridge_vlan_msg_parser,
+	.co_obj_ops = &bridge_vlan_obj_ops,
+};
+
+/**
+ * @name Cache Management
+ * @{
+ */
+int rtnl_bridge_vlan_alloc_cache(struct nl_sock *sk, struct nl_cache **result)
+{
+	return nl_cache_alloc_and_fill(&bridge_vlan_ops, sk, result);
+}
+
+/**
+ * Build a bridge vlan cache including all Bridge VLAN entries currently configured in the kernel.
+ * @arg sock		Netlink socket.
+ * @arg result		Pointer to store resulting cache.
+ * @arg flags		Flags to apply to cache before filling
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_bridge_vlan_alloc_cache_flags(struct nl_sock *sock,
+				       struct nl_cache **result,
+				       unsigned int flags)
+{
+	struct nl_cache *cache = NULL;
+	int err;
+
+	cache = nl_cache_alloc(&bridge_vlan_ops);
+	if (!cache)
+		return -NLE_NOMEM;
+
+	nl_cache_set_flags(cache, flags);
+
+	if (sock && (err = nl_cache_refill(sock, cache)) < 0) {
+		nl_cache_free(cache);
+		return err;
+	}
+
+	*result = cache;
+	return 0;
+}
+
+/** @} */
+
+/**
+ * @name Add / Modify
+ * @{
+ */
+
+static int build_bridge_vlan_msg(int cmd, struct br_vlan_msg *hdr,
+				 struct rtnl_bridge_vlan *link, int flags,
+				 struct nl_msg **result)
+{
+	struct nl_msg *msg;
+	msg = nlmsg_alloc_simple(cmd, flags);
+	if (!msg)
+		return -NLE_NOMEM;
+
+	*result = msg;
+	return 0;
+}
+
+int rtnl_bridge_vlan_build_change_request(struct rtnl_bridge_vlan *orig,
+					  struct rtnl_bridge_vlan *changes,
+					  int flags, struct nl_msg **result)
+{
+	struct br_vlan_msg bvlan = {
+		.family = orig->family,
+		.ifindex = orig->ifindex,
+	};
+	int err, rt;
+
+	build_bridge_vlan_msg(RTM_SETLINK, &bvlan, changes, flags, result);
+
+	return 0;
+}
+
+int rtnl_bridge_vlan_change(struct nl_sock *sk, struct rtnl_bridge_vlan *orig,
+			    struct rtnl_bridge_vlan *changes, int flags)
+{
+	struct nl_msg *msg;
+	int err;
+
+	err = rtnl_bridge_vlan_build_change_request(orig, changes, flags, &msg);
+
+	BUG_ON(msg->nm_nlh->nlmsg_seq != NL_AUTO_SEQ);
+retry:
+	err = nl_send_auto_complete(sk, msg);
+	if (err < 0)
+		goto errout;
+
+	err = wait_for_ack(sk);
+	if (err == -NLE_OPNOTSUPP && msg->nm_nlh->nlmsg_type == RTM_NEWLINK) {
+		msg->nm_nlh->nlmsg_type = RTM_SETLINK;
+		msg->nm_nlh->nlmsg_seq = NL_AUTO_SEQ;
+		goto retry;
+	}
+
+errout:
+	nlmsg_free(msg);
+	return err;
+}
+
+/** @} */
+
+/**
+ * @name Get/ Set
+ * @{
+ */
+void rtnl_bridge_vlan_add_entry(struct rtnl_bridge_vlan *bvlan,
+				struct rtnl_bvlan_entry *entry)
+{
+	nl_list_add_tail(&entry->bridge_vlan_entry_list,
+			 &bvlan->bridge_vlan_list);
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_get(struct nl_cache *cache,
+					      int ifindex)
+{
+	struct rtnl_bridge_vlan *bvlan_entry;
+
+	if (cache->c_ops != &rtnl_bridge_vlan_ops)
+		return NULL;
+
+	nl_list_for_each_entry(bvlan_entry, &cache->c_items, ce_list) {
+		if (bvlan_entry->ifindex == ifindex) {
+			nl_object_get((struct nl_object *) bvlan_entry);
+			return bvlan_entry;
+		}
+	}
+
+	return NULL;
+
+}
+
+struct rtnl_bvlan_entry *rtnl_bridge_vlan_get_entry_head(struct rtnl_bridge_vlan
+							 *obj)
+{
+	return nl_list_first_entry(&obj->bridge_vlan_list,
+				   struct rtnl_bvlan_entry,
+				   bridge_vlan_entry_list);
+
+}
+
+void rtnl_bridge_vlan_foreach_entry(struct rtnl_bridge_vlan *obj,
+				    void (*cb)(struct rtnl_bvlan_entry *,
+					       void *), void *arg)
+{
+	struct rtnl_bvlan_entry *entry;
+	nl_list_for_each_entry(entry, &obj->bridge_vlan_list,
+			       bridge_vlan_entry_list) {
+		cb(entry, arg);
+	}
+}
+
+int rtnl_bridge_vlan_get_ifindex(struct rtnl_bridge_vlan *bvlan)
+{
+	return bvlan->ifindex;
+}
+
+int rtnl_bridge_vlan_set_ifindex(struct rtnl_bridge_vlan *bvlan, int ifindex)
+{
+	bvlan->ifindex = ifindex;
+	return 0;
+}
+
+int rtnl_bridge_vlan_entry_get_vlan_id(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->vlan_id;
+}
+
+int rtnl_bridge_vlan_entry_set_vlan_id(struct rtnl_bvlan_entry *bvlan,
+				       uint16_t vid)
+{
+	bvlan->vlan_id = vid;
+	return 0;
+}
+
+uint8_t rtnl_bridge_vlan_entry_get_state(struct rtnl_bvlan_entry *bvlan)
+{
+	return bvlan->state;
+}
+
+int rtnl_bridge_vlan_entry_set_state(struct rtnl_bvlan_entry *bvlan,
+				     uint8_t state)
+{
+	bvlan->state = state;
+	return 0;
+}
+
+/** @} */
+
+struct rtnl_bvlan_entry *rtnl_bvlan_entry_alloc(void)
+{
+	struct rtnl_bvlan_entry *entry;
+
+	entry = calloc(1, sizeof(struct rtnl_bvlan_entry));
+	if (!entry)
+		return NULL;
+	return entry;
+}
+
+struct rtnl_bridge_vlan *rtnl_bridge_vlan_alloc(void)
+{
+	return (struct rtnl_bridge_vlan *)
+	    nl_object_alloc(&bridge_vlan_obj_ops);
+}
+
+void rtnl_bridge_vlan_put(struct rtnl_bridge_vlan *bvlan)
+{
+	nl_object_put((struct nl_object *) bvlan);
+
+}
+
+static void __init bridge_vlan_init(void)
+{
+	nl_cache_mngt_register(&bridge_vlan_ops);
+}
+
+static void __exit bridge_vlan_exit(void)
+{
+	nl_cache_mngt_register(&bridge_vlan_ops);
+}
+
+/** @} */
diff --git a/libnl-cli-3.sym b/libnl-cli-3.sym
index 71ff2eb..ed3bf34 100644
--- a/libnl-cli-3.sym
+++ b/libnl-cli-3.sym
@@ -114,4 +114,7 @@ global:
 	nl_cli_alloc_cache_flags;
 	nl_cli_link_alloc_cache_flags;
 	nl_cli_link_alloc_cache_family_flags;
+	nl_cli_bridge_vlan_alloc;
+	nl_cli_bridge_vlan_alloc_cache_flags;
+	nl_cli_bridge_vlan_parse_ifindex;
 } libnl_3;
diff --git a/libnl-route-3.sym b/libnl-route-3.sym
index dc89700..b276b24 100644
--- a/libnl-route-3.sym
+++ b/libnl-route-3.sym
@@ -1172,4 +1172,15 @@ libnl_3_6 {
 	rtnl_mdb_entry_get_proto;
 	rtnl_mdb_entry_get_state;
 	rtnl_mdb_entry_get_vid;
+	rtnl_bridge_vlan_alloc;
+	rtnl_bridge_vlan_alloc_cache;
+	rtnl_bridge_vlan_alloc_cache_flags;
+	rtnl_bridge_vlan_get_ifindex;
+	rtnl_bridge_vlan_set_ifindex;
+	rtnl_bridge_vlan_entry_get_vlan_id;
+	rtnl_bridge_vlan_entry_set_vlan_id;
+	rtnl_bridge_vlan_entry_get_state;
+	rtnl_bridge_vlan_add_entry;
+	rtnl_bridge_vlan_foreach_entry;
+	rtnl_bridge_vlan_get_entry_head;
 } libnl_3_5;
diff --git a/src/nl-bridge.c b/src/nl-bridge.c
new file mode 100644
index 0000000..32530fe
--- /dev/null
+++ b/src/nl-bridge.c
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: LGPL-2.1-only */
+/*
+ * src/nl-bridge.c     Bridge utility
+ */
+
+#include <netlink/netlink.h>
+#include <netlink/cache.h>
+#include <netlink/cli/utils.h>
+#include <netlink/cli/bridge_vlan.h>
+#include <netlink/cli/link.h>
+
+#include <netlink-private/cache-api.h>
+#include <linux/netlink.h>
+
+int main(int argc, char *argv[])
+{
+	struct nl_sock *sock;
+	struct rtnl_link *bridge;
+	struct rtnl_bridge_vlan *bvlan = nl_cli_bridge_vlan_alloc();
+	struct nl_cache *bvlan_cache;
+	int err;
+	struct nl_dump_params dp = {
+		.dp_type = NL_DUMP_DETAILS,
+		.dp_fd = stdout,
+	};
+
+	struct nl_cache_mngr *mngr;
+
+	sock = nl_cli_alloc_socket();
+	nl_cli_connect(sock, NETLINK_ROUTE);
+	bvlan_cache = nl_cli_bridge_vlan_alloc_cache_flags(sock, NL_CACHE_AF_ITER);
+
+	nl_cache_dump(bvlan_cache, &dp);
+
+	printf("end\n");
+
+	return 0;
+}
diff --git a/src/nl-monitor.c b/src/nl-monitor.c
index 99aa0f4..a9e40c9 100644
--- a/src/nl-monitor.c
+++ b/src/nl-monitor.c
@@ -38,6 +38,7 @@ static const struct {
 	{ RTNLGRP_IPV6_NETCONF, "ipv6-netconf" },
 	{ RTNLGRP_MPLS_NETCONF, "mpls-netconf" },
 	{ RTNLGRP_MDB, "mdb" },
+	{ RTNLGRP_BRVLAN, "bridge-vlan" },
 	{ RTNLGRP_NONE, NULL }
 };
 
-- 
2.29.2

